import * as vscode from "vscode";
import * as path from "path";
import * as crypto from "crypto";
import { AIRequestService } from "../services/aiRequestService";
import {
	ContextService,
	ActiveSymbolDetailedInfo,
} from "../services/contextService";
import { cleanCodeOutput } from "../utils/codeUtils";
import { DiagnosticService, getSeverityName } from "../utils/diagnosticUtils";
import { generateFileChangeSummary } from "../utils/diffingUtils";
import { getIssueIdentifier, areIssuesSimilar } from "../utils/aiUtils";
import { ExtensionToWebviewMessages } from "../sidebar/common/sidebarTypes";
import { ProjectChangeLogger } from "../workflow/ProjectChangeLogger";
import { RevertibleChangeSet } from "../types/workflow";

// NEW IMPORTS FOR PROMPT GENERATOR FUNCTIONS
import {
	createEnhancedGenerationPrompt,
	createRefinementPrompt,
	createEnhancedModificationPrompt,
	createRefineModificationPrompt,
	createAlternativeCorrectionPrompt,
	createSyntaxCorrectionPrompt,
	createImportCorrectionPrompt,
	createPracticeCorrectionPrompt,
	createSecurityCorrectionPrompt,
	createAIFailureAnalysisPrompt,
	createPureCodeFormatCorrectionPrompt,
} from "./prompts/enhancedCodeGenerationPrompts";

/**
 * Real-time feedback interface for code generation
 */
interface RealTimeFeedback {
	stage: string;
	message: string;
	issues: CodeIssue[];
	suggestions: string[];
	progress: number; // 0-100
}

export interface CodeValidationResult {
	isValid: boolean;
	finalContent: string;
	issues: CodeIssue[];
	suggestions: string[];
	iterations?: number;
	totalIssues?: number;
	resolvedIssues?: number;
}

export interface CodeIssue {
	type:
		| "syntax"
		| "unused_import"
		| "best_practice"
		| "security"
		| "other"
		| "format_error"; // NEW: Add format_error type
	message: string;
	line: number;
	severity: "error" | "warning" | "info";
	code?: string | number;
	source?: string;
}

export interface FileAnalysis {
	framework: string;
	projectStructure: string;
	expectedPatterns: string;
	fileName: string;
	extension: string;
}

export interface FileStructureAnalysis {
	imports: Array<{ line: number; content: string }>;
	exports: Array<{ line: number; content: string }>;
	functions: Array<{ line: number; content: string }>;
	classes: Array<{ line: number; content: string }>;
	variables: Array<{ line: number; content: string }>;
	comments: Array<{ line: number; content: string }>;
}

export interface DiffAnalysis {
	isReasonable: boolean;
	issues: string[];
	changeRatio: number;
}

/**
 * Encapsulates details about a single correction attempt that did not yield the desired result.
 */
export interface CorrectionAttemptOutcome {
	success: boolean; // Indicates whether the correction attempt resulted in an improvement or at least maintained the status quo
	iteration: number; // The specific iteration number within the _generateWithRealTimeFeedback loop
	originalIssuesCount: number; // The number of issues identified before this correction attempt
	issuesAfterAttemptCount: number; // The number of issues identified after this correction attempt
	issuesRemaining: CodeIssue[]; // A list of CodeIssue objects that were still present after the attempt
	issuesIntroduced: CodeIssue[]; // A list of *new* CodeIssue objects introduced by this attempt
	relevantDiff: string; // The generated code diff representing the changes made in this attempt
	aiFailureAnalysis: string; // The crucial textual diagnosis generated by the AI itself, explaining *why* it believes the attempt failed
	failureType:
		| "no_improvement"
		| "new_errors_introduced"
		| "parsing_failed"
		| "unreasonable_diff"
		| "command_failed"
		| "unknown"; // A categorical reason for the failure
}

// NEW: Define EnhancedGenerationContext interface
export interface EnhancedGenerationContext {
	projectContext: string;
	relevantSnippets: string;
	editorContext?: any;
	activeSymbolInfo?: ActiveSymbolDetailedInfo;
	fileStructureAnalysis?: FileStructureAnalysis;
	lastFailedCorrectionDiff?: string;
	successfulChangeHistory?: string; // NEW: Added property
	lastCorrectionAttemptOutcome?: CorrectionAttemptOutcome; // NEW: Added property
	recentCorrectionAttemptOutcomes?: CorrectionAttemptOutcome[]; // NEW: Added property
	isOscillating?: boolean; // NEW: Added property
	relevantFiles?: string; // NEW: Added property as per instructions
	isRewriteOperation?: boolean; // NEW: Added property to indicate rewrite intent
}

/**
 * Get language ID from file extension
 */
function getLanguageId(extension: string): string {
	const languageMap: Record<string, string> = {
		".ts": "typescript",
		".tsx": "typescript",
		".js": "javascript",
		".jsx": "javascript",
		".py": "python",
		".java": "java",
		".cs": "csharp",
		".cpp": "cpp",
		".c": "c",
		".go": "go",
		".rs": "rust",
		".php": "php",
		".rb": "ruby",
		".swift": "swift",
		".kt": "kotlin",
	};

	return languageMap[extension] || "text";
}

/**
 * Extracts a code snippet around a given line number.
 * @param fullContent The full string content of the file.
 * @param lineNumber The 1-indexed line number to center the snippet around.
 * @param linesBefore The number of lines to include before the target line.
 * @param linesAfter The number of lines to include after the target line.
 * @returns A string containing the formatted code snippet.
 */
function getCodeSnippet(
	fullContent: string,
	lineNumber: number,
	linesBefore: number = 2,
	linesAfter: number = 2
): string {
	const lines = fullContent.split("\n");
	const zeroBasedLineNumber = lineNumber - 1; // Convert to 0-indexed

	const start = Math.max(0, zeroBasedLineNumber - linesBefore);
	const end = Math.min(lines.length - 1, zeroBasedLineNumber + linesAfter);

	const snippetLines: string[] = [];
	const maxLineNumLength = String(end + 1).length; // For padding

	for (let i = start; i <= end; i++) {
		const currentLineNum = i + 1; // Convert back to 1-indexed for display
		const paddedLineNum = String(currentLineNum).padStart(
			maxLineNumLength,
			" "
		);
		snippetLines.push(`${paddedLineNum}: ${lines[i]}`);
	}

	return snippetLines.join("\n");
}

/**
 * Groups and prioritizes code issues for prompt generation.
 * Issues are grouped by a combination of type, severity, and specific code (if applicable).
 * Priorities are based on predefined orders (`issueTypeOrder`, `severityOrder`).
 * Special handling for 'cannot find name' errors by grouping them by the missing identifier.
 * @param issues An array of CodeIssue objects.
 * @returns A Map where keys are formatted group headers and values are arrays of CodeIssue.
 */
function groupAndPrioritizeIssues(
	issues: CodeIssue[],
	issueTypeOrder: CodeIssue["type"][],
	severityOrder: CodeIssue["severity"][]
): Map<string, CodeIssue[]> {
	const groupedIssues = new Map<string, CodeIssue[]>();

	// Sort issues initially based on predefined order and then line number
	issues.sort((a, b) => {
		const typeOrderA = issueTypeOrder.indexOf(a.type);
		const typeOrderB = issueTypeOrder.indexOf(b.type);
		if (typeOrderA !== typeOrderB) {
			return typeOrderA - typeOrderB;
		}

		const severityOrderA = severityOrder.indexOf(a.severity);
		const severityOrderB = severityOrder.indexOf(b.severity);
		if (severityOrderA !== severityOrderB) {
			return severityOrderA - severityOrderB;
		}

		return a.line - b.line;
	});

	for (const issue of issues) {
		let groupKey = "";
		// Special grouping for 'cannot find name' errors
		if (
			issue.message.includes("Cannot find name") &&
			issue.type === "syntax" &&
			issue.severity === "error"
		) {
			const match = issue.message.match(/Cannot find name '([^']*)'/);
			const missingName = match ? match[1] : "unknown_identifier"; // Use "unknown_identifier" for clarity
			groupKey = `TYPE: ${issue.type.toUpperCase()} / SEVERITY: ${issue.severity.toUpperCase()} / ISSUE: Missing Identifier '${missingName}'`;
		} else {
			groupKey = `TYPE: ${issue.type.toUpperCase()} / SEVERITY: ${issue.severity.toUpperCase()}${
				issue.code ? ` / CODE: ${issue.code}` : ""
			}`;
		}

		if (!groupedIssues.has(groupKey)) {
			groupedIssues.set(groupKey, []);
		}
		groupedIssues.get(groupKey)!.push(issue);
	}

	return groupedIssues;
}

/**
 * Formats grouped and prioritized issues into a Markdown string for AI prompts.
 * @param groupedIssues A Map of grouped CodeIssue objects.
 * @param languageId The language ID of the file (e.g., 'typescript', 'javascript').
 * @param content The full content of the file to extract code snippets.
 * @returns A formatted Markdown string representing the issues.
 */
function formatGroupedIssuesForPrompt(
	groupedIssues: Map<string, CodeIssue[]>,
	languageId: string,
	content: string,
	issueTypeOrder: CodeIssue["type"][],
	severityOrder: CodeIssue["severity"][],
	getCodeSnippetFn: (
		content: string,
		lineNumber: number,
		linesBefore?: number,
		linesAfter?: number
	) => string
): string {
	let formattedString = "";

	// Sort group keys based on issue type and severity order
	const sortedGroupKeys = Array.from(groupedIssues.keys()).sort(
		(keyA, keyB) => {
			const issueTypeA =
				issueTypeOrder.find((type) =>
					keyA.includes(`TYPE: ${type.toUpperCase()}`)
				) || "other";
			const issueTypeB =
				issueTypeOrder.find((type) =>
					keyB.includes(`TYPE: ${type.toUpperCase()}`)
				) || "other";
			const typeOrderResult =
				issueTypeOrder.indexOf(issueTypeA as CodeIssue["type"]) -
				issueTypeOrder.indexOf(issueTypeB as CodeIssue["type"]);
			if (typeOrderResult !== 0) {
				return typeOrderResult;
			}

			const severityA =
				severityOrder.find((severity) =>
					keyA.includes(`SEVERITY: ${severity.toUpperCase()}`)
				) || "info";
			const severityB =
				severityOrder.find((severity) =>
					keyB.includes(`SEVERITY: ${severity.toUpperCase()}`)
				) || "info";
			return (
				severityOrder.indexOf(severityA as CodeIssue["severity"]) -
				severityOrder.indexOf(severityB as CodeIssue["severity"])
			);
		}
	);

	for (const groupKey of sortedGroupKeys) {
		const issuesInGroup = groupedIssues.get(groupKey)!;
		formattedString += `--- Issue Group: ${groupKey} ---\n`;

		// Add suggested strategy for the group
		let suggestedStrategy =
			"Review the provided code snippet and diagnostic message. Apply the most targeted fix to resolve this specific issue while adhering to all critical requirements.";
		if (groupKey.includes("ISSUE: Missing Identifier")) {
			suggestedStrategy =
				"Suggested Strategy: This group contains 'Cannot find name' errors, indicating a missing identifier. This almost always means a missing import statement, a typo in a variable/function/type name, or an undeclared variable/constant. Your specific action should be: 1. **Check Imports**: Verify if the missing identifier is an external dependency or a local module export; add the necessary import statement if it's missing. 2. **Check Typos**: Meticulously review the spelling of the identifier in both its usage and declaration. 3. **Check Scope/Declaration**: Ensure the identifier is declared and accessible within the current scope. If it's an undeclared variable, declare it with the correct type. Pay close attention to case sensitivity.";
		} else if (groupKey.includes("TYPE: UNUSED_IMPORT")) {
			suggestedStrategy =
				"Suggested Strategy: This group contains unused import warnings. This indicates an an import statement that is no longer being used by any code within the file. Your specific action should be: 1. **Remove Statement**: Delete the entire unused import statement. 2. **Verify No Reliance**: Before removal, quickly scan the file to ensure no other code unexpectedly relies on this import (e.g., dynamic usage not caught by static analysis).";
		} else if (groupKey.includes("TYPE: SECURITY")) {
			suggestedStrategy =
				"Suggested Strategy: This group contains security issues or vulnerabilities. Your specific action should be: 1. **Implement Secure Practices**: Apply standard secure coding practices relevant to the language and context (e.g., input validation, output encoding, proper authentication/authorization, secure data handling). 2. **Mitigate Vulnerability**: Directly address the vulnerability described in the message (e.g., prevent XSS, SQL injection, path traversal).";
		} else if (groupKey.includes("TYPE: BEST_PRACTICE")) {
			suggestedStrategy =
				"Suggested Strategy: This group contains best practice issues. These are typically suggestions for improving code quality, readability, maintainability, or performance, rather than critical errors. Your specific action should be: 1. **Refine Code**: Refactor small sections to align with established coding patterns, improve naming conventions, or use more idiomatic language features. 2. **Enhance Readability/Maintainability**: Focus on clarity, simplicity, and consistency without introducing new bugs.";
		} else if (
			groupKey.includes("TYPE: SYNTAX") &&
			groupKey.includes("ERROR")
		) {
			suggestedStrategy =
				"Suggested Strategy: This group contains critical syntax errors that prevent the code from compiling or parsing correctly. Your specific action should be: 1. **Correct Exact Mistake**: Focus solely on fixing the precise syntax mistake indicated by the diagnostic message (e.g., missing semicolon, incorrect keyword usage, mismatched parentheses/braces, incorrect function signature). 2. **Minimal Changes**: Ensure changes are localized and do not affect surrounding correct code.";
		} else if (groupKey.includes("TYPE: OTHER")) {
			suggestedStrategy =
				"Suggested Strategy: This group contains general or uncategorized issues. While not falling into specific categories, they still require attention. Your specific action should be: 1. **Analyze Message**: Carefully read the diagnostic message and examine the problematic code snippet. 2. **Precise Fix**: Apply a targeted and precise fix that directly resolves the issue without introducing unnecessary changes or side effects.";
		} else if (groupKey.includes("TYPE: FORMAT_ERROR")) {
			// NEW: Strategy for format errors
			suggestedStrategy =
				"Suggested Strategy: The AI's response format was incorrect. It likely did not provide code within BEGIN_CODE/END_CODE delimiters or included significant conversational text. Your specific action should be: 1. **Strictly adhere to delimiters**: Ensure all generated code is ONLY between `BEGIN_CODE` and `END_CODE`. 2. **Remove extraneous text**: Eliminate all conversational filler, explanations, markdown formatting (triple backticks), or meta-headers outside the delimiters. 3. **Deliver pure code**: Focus solely on generating valid, executable code.";
		}
		formattedString += `Suggested Strategy: ${suggestedStrategy}\n`;

		for (const issue of issuesInGroup) {
			formattedString += `--- Individual Issue Details ---\n`;
			formattedString += `Severity: ${issue.severity.toUpperCase()}\n`;
			formattedString += `Type: ${issue.type}\n`;
			formattedString += `Line: ${issue.line}\n`;
			formattedString += `Message: ${issue.message}\n`;
			if (issue.code) {
				formattedString += `Issue Code: ${issue.code}\n`;
			}
			formattedString += `Problematic Code Snippet:\n`;
			formattedString += `\`\`\`${languageId}\n`;
			formattedString += `${getCodeSnippetFn(content, issue.line)}\n`;
			formattedString += `\`\`\`\n`;
			formattedString += `--- End Individual Issue Details ---\n\n`;
		}
		formattedString += "\n"; // Add extra newline between groups
	}

	return formattedString;
}

/**
 * Enhanced code generation with improved accuracy through:
 * 1. Better context analysis
 * 2. Code validation and refinement
 * 3. Dependency analysis
 * 4. Style consistency enforcement
 * 5. Error prevention
 * 6. Inline edit support for precise modifications
 * 7. Real-time feedback loop for immediate validation
 */
export class EnhancedCodeGenerator {
	// NEW: Define issue ordering constants
	private readonly issueTypeOrder: CodeIssue["type"][] = [
		"format_error", // Prioritize format errors
		"syntax",
		"unused_import",
		"security",
		"best_practice",
		"other",
	];
	private readonly severityOrder: CodeIssue["severity"][] = [
		"error",
		"warning",
		"info",
	];

	private readonly MAX_OSCILLATION_HISTORY_SIZE = 3; // Number of recent failed attempts to keep in context for oscillation detection

	constructor(
		private aiRequestService: AIRequestService,
		private workspaceRoot: vscode.Uri,
		private postMessageToWebview: (message: ExtensionToWebviewMessages) => void,
		private changeLogger: ProjectChangeLogger, // MODIFIED: Add changeLogger parameter
		private contextService: ContextService, // NEW: Add contextService parameter
		private config: {
			enableRealTimeFeedback?: boolean;
			maxFeedbackIterations?: number;
		} = {}
	) {
		// Set defaults
		this.config.enableRealTimeFeedback =
			this.config.enableRealTimeFeedback ?? true;
		this.config.maxFeedbackIterations = this.config.maxFeedbackIterations ?? 5;
	}

	/**
	 * Enhanced file content generation with real-time feedback loop
	 */
	public async generateFileContent(
		filePath: string,
		generatePrompt: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		token?: vscode.CancellationToken,
		feedbackCallback?: (feedback: RealTimeFeedback) => void,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<{ content: string; validation: CodeValidationResult }> {
		const languageId = getLanguageId(path.extname(filePath));
		const streamId = crypto.randomUUID();

		this.postMessageToWebview({
			type: "codeFileStreamStart",
			value: { streamId: streamId, filePath: filePath, languageId: languageId },
		});

		try {
			// Determine rewrite intent early
			const isRewriteOperation = this._isRewriteIntentDetected(
				generatePrompt,
				filePath
			);
			const contextForGeneration: EnhancedGenerationContext = {
				...context,
				isRewriteOperation: isRewriteOperation,
			};

			if (this.config.enableRealTimeFeedback) {
				const result = await this._generateWithRealTimeFeedback(
					filePath,
					generatePrompt,
					contextForGeneration,
					modelName,
					streamId,
					token,
					feedbackCallback,
					onCodeChunkCallback
				);
				this.postMessageToWebview({
					type: "codeFileStreamEnd",
					value: { streamId: streamId, filePath: filePath, success: true },
				});
				return result;
			} else {
				// Non-real-time feedback path also needs initial context setup.
				// This branch is rarely used in practice with `enableRealTimeFeedback` typically true.
				const fileStructureAnalysis = await this._analyzeFileStructure(
					filePath,
					"" // Pass empty string as content is not yet generated
				);
				const successfulChangeHistory = this._formatSuccessfulChangesForPrompt(
					this.changeLogger.getCompletedPlanChangeSets()
				);
				const initialGenerationContext: EnhancedGenerationContext = {
					...contextForGeneration, // Use context with isRewriteOperation
					fileStructureAnalysis: fileStructureAnalysis,
					successfulChangeHistory: successfulChangeHistory,
					lastFailedCorrectionDiff: undefined, // No failed diff yet
				};

				const initialGenerationResult = await this._generateInitialContent(
					// MODIFIED: Get CodeValidationResult
					filePath,
					generatePrompt,
					initialGenerationContext,
					modelName,
					streamId,
					token,
					onCodeChunkCallback
				);

				// MODIFIED: If initial content generation results in a format error, propagate it
				if (!initialGenerationResult.isValid) {
					this.postMessageToWebview({
						type: "codeFileStreamEnd",
						value: {
							streamId: streamId,
							filePath: filePath,
							success: false,
							error: `Initial generation format error: ${initialGenerationResult.issues[0]?.message}`,
						},
					});
					return {
						content: initialGenerationResult.finalContent, // Return the problematic content for inspection
						validation: initialGenerationResult,
					};
				}

				const validation = await this._validateAndRefineContent(
					filePath,
					initialGenerationResult.finalContent, // Use the cleaned content
					initialGenerationContext, // Pass context with structured analysis
					modelName,
					streamId,
					token,
					onCodeChunkCallback
				);

				const result = {
					content: validation.finalContent,
					validation,
				};
				this.postMessageToWebview({
					type: "codeFileStreamEnd",
					value: { streamId: streamId, filePath: filePath, success: true },
				});
				return result;
			}
		} catch (error: any) {
			this.postMessageToWebview({
				type: "codeFileStreamEnd",
				value: {
					streamId: streamId,
					filePath: filePath,
					success: false,
					error: error instanceof Error ? error.message : String(error),
				},
			});
			throw error;
		}
	}

	/**
	 * Enhanced file modification with intelligent diff analysis and inline edit support
	 */
	public async modifyFileContent(
		filePath: string,
		modificationPrompt: string,
		currentContent: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<{ content: string; validation: CodeValidationResult }> {
		const languageId = getLanguageId(path.extname(filePath));
		const streamId = crypto.randomUUID();

		this.postMessageToWebview({
			type: "codeFileStreamStart",
			value: { streamId: streamId, filePath: filePath, languageId: languageId },
		});

		try {
			// Determine rewrite intent early
			const isRewriteOperation = this._isRewriteIntentDetected(
				modificationPrompt,
				filePath
			);
			const contextForModification: EnhancedGenerationContext = {
				...context,
				isRewriteOperation: isRewriteOperation,
			};

			const result = await this._modifyFileContentFull(
				filePath,
				modificationPrompt,
				currentContent,
				contextForModification, // Pass context with isRewriteOperation
				modelName,
				streamId,
				token,
				onCodeChunkCallback
			);
			this.postMessageToWebview({
				type: "codeFileStreamEnd",
				value: { streamId: streamId, filePath: filePath, success: true },
			});
			return result;
		} catch (error: any) {
			this.postMessageToWebview({
				type: "codeFileStreamEnd",
				value: {
					streamId: streamId,
					filePath: filePath,
					success: false,
					error: error instanceof Error ? error.message : String(error),
				},
			});
			throw error;
		}
	}

	/**
	 * Create a new private method _checkPureCodeFormat within the EnhancedCodeGenerator class.
	 * This method will accept the raw AI response string and perform the heuristic checks
	 * described for cleanCodeOutput (specifically, for BEGIN_CODE/END_CODE delimiters).
	 * If garbled or non-code output is detected, it should return a CodeValidationResult
	 * object with isValid: false, and a CodeIssue of type "format_error".
	 */
	private _checkPureCodeFormat(rawAIResponse: string): CodeValidationResult {
		const issues: CodeIssue[] = [];
		const suggestions: string[] = [];
		let isValidFormat = true;
		let finalContent: string;

		const BEGIN_CODE_REGEX = /BEGIN_CODE\n?([\s\S]*?)\n?END_CODE/i;
		const delimiterMatch = rawAIResponse.match(BEGIN_CODE_REGEX);

		if (delimiterMatch && delimiterMatch[1] !== undefined) {
			// Delimiters found, extract content within them.
			finalContent = delimiterMatch[1].trim();
			if (finalContent.length === 0) {
				isValidFormat = false;
				issues.push({
					type: "format_error",
					message:
						"AI response contained BEGIN_CODE/END_CODE delimiters but no code within them.",
					line: 1,
					severity: "error",
					source: "PureCodeFormatCheck",
				});
				suggestions.push("AI generated empty code block inside delimiters.");
			}
		} else {
			// Delimiters not found. This is a format error.
			isValidFormat = false;
			issues.push({
				type: "format_error",
				message:
					"AI response did not contain the required BEGIN_CODE/END_CODE delimiters.",
				line: 1,
				severity: "error",
				source: "PureCodeFormatCheck",
			});
			suggestions.push(
				"Instruct the AI to strictly enclose all generated code within BEGIN_CODE and END_CODE markers."
			);

			// As a fallback for content extraction, attempt to clean anyway,
			// even though the format is considered problematic.
			finalContent = cleanCodeOutput(rawAIResponse);
		}

		return {
			isValid: isValidFormat,
			finalContent: finalContent,
			issues: issues,
			suggestions: suggestions,
		};
	}

	/**
	 * Generate initial content with enhanced context analysis
	 */
	private async _generateInitialContent(
		filePath: string,
		generatePrompt: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<CodeValidationResult> {
		// MODIFIED: Return CodeValidationResult
		const fileExtension = path.extname(filePath);
		// languageId not strictly needed for _checkPureCodeFormat, but kept for context if needed later
		// const languageId = getLanguageId(fileExtension);

		// Enhanced prompt with better context analysis
		const enhancedPrompt = createEnhancedGenerationPrompt(
			filePath,
			generatePrompt,
			context
		);

		try {
			const rawContent = await this.aiRequestService.generateWithRetry(
				[{ text: enhancedPrompt }], // Modified: Wrap prompt string in HistoryEntryPart array
				modelName,
				undefined,
				"enhanced file generation",
				undefined,
				{
					onChunk: async (chunk: string) => {
						this.postMessageToWebview({
							type: "codeFileStreamChunk",
							value: { streamId: streamId, filePath: filePath, chunk: chunk },
						});
						if (onCodeChunkCallback) {
							await onCodeChunkCallback(chunk);
						}
					},
				},
				token
			);

			// NEW: Immediately call _checkPureCodeFormat on the raw AI response
			const formatValidation = this._checkPureCodeFormat(rawContent);
			return formatValidation; // Return the validation result directly
		} catch (error: any) {
			// If generation itself fails, wrap it in a CodeValidationResult for consistent return type
			return {
				isValid: false,
				finalContent: "", // No content on generation error
				issues: [
					{
						type: "other",
						message: `AI generation failed: ${
							error instanceof Error ? error.message : String(error)
						}`,
						line: 1,
						severity: "error",
						source: "AIGeneration",
					},
				],
				suggestions: ["Check AI service status or prompt clarity."],
			};
		}
	}

	/**
	 * Validate and refine generated content
	 */
	private async _validateAndRefineContent(
		filePath: string,
		content: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<CodeValidationResult> {
		const validation = await this._validateCode(filePath, content);

		if (validation.isValid) {
			return {
				isValid: true,
				finalContent: content,
				issues: [],
				suggestions: validation.suggestions,
			};
		}

		// Refine content if validation failed
		const refinementPromptString = createRefinementPrompt(
			filePath,
			content,
			validation.issues,
			context
		);

		const rawRefinedContent = await this.aiRequestService.generateWithRetry(
			[{ text: refinementPromptString }],
			modelName,
			undefined,
			"refine content",
			undefined,
			{
				onChunk: async (chunk: string) => {
					this.postMessageToWebview({
						type: "codeFileStreamChunk",
						value: { streamId: streamId, filePath: filePath, chunk: chunk },
					});
					if (onCodeChunkCallback) {
						await onCodeChunkCallback(chunk);
					}
				},
			},
			token
		);

		const refinedContent = cleanCodeOutput(rawRefinedContent);

		const finalValidation = await this._validateCode(filePath, refinedContent);

		return {
			isValid: finalValidation.isValid,
			finalContent: refinedContent,
			issues: finalValidation.issues,
			suggestions: finalValidation.suggestions,
		};
	}

	/**
	 * Validate code for common issues
	 */
	private async _validateCode(
		filePath: string,
		content: string
	): Promise<CodeValidationResult> {
		const issues: CodeIssue[] = [];
		const suggestions: string[] = [];
		let hasError = false;

		const fileUri = vscode.Uri.file(filePath);
		const diagnostics = DiagnosticService.getDiagnosticsForUri(fileUri);

		for (const diag of diagnostics) {
			const severityName = getSeverityName(diag.severity);
			let issueSeverity: CodeIssue["severity"];
			let issueType: CodeIssue["type"];

			// Map VS Code severity to CodeIssue severity
			if (severityName === "Error") {
				issueSeverity = "error";
				hasError = true;
			} else if (severityName === "Warning") {
				issueSeverity = "warning";
			} else {
				issueSeverity = "info";
			}

			// Map VS Code diagnostic to CodeIssue type (prioritize specific types, then broad categories)
			const messageLower = diag.message.toLowerCase();
			if (messageLower.includes("unused import")) {
				issueType = "unused_import";
			} else if (
				issueSeverity === "error" ||
				issueSeverity === "warning" ||
				messageLower.includes("syntax") ||
				messageLower.includes("compilation") ||
				messageLower.includes("lint")
			) {
				issueType = "syntax"; // General compilation/linting issues
			} else if (messageLower.includes("security")) {
				issueType = "security"; // Explicitly map security if mentioned
			} else if (messageLower.includes("best practice")) {
				issueType = "best_practice"; // Explicitly map best practice if mentioned
			} else {
				issueType = "other"; // General fallback
			}

			let issueCode: string | number | undefined;
			if (
				typeof diag.code === "object" &&
				diag.code !== null &&
				"value" in diag.code
			) {
				issueCode = (diag.code as { value: string | number }).value;
			} else if (
				typeof diag.code === "string" ||
				typeof diag.code === "number"
			) {
				issueCode = diag.code;
			}

			issues.push({
				type: issueType,
				message: diag.message,
				line: diag.range.start.line + 1, // VS Code diagnostics are 0-indexed, CodeIssue is 1-indexed
				severity: issueSeverity,
				code: issueCode,
			});
		}

		// Generate suggestions for improvement
		if (issues.length === 0) {
			suggestions.push(
				"Code appears to be well-structured and follows best practices"
			);
		} else {
			suggestions.push(
				"Consider addressing the identified issues for better code quality"
			);
		}

		return {
			isValid: !hasError, // isValid is false if any error diagnostic is found
			finalContent: content, // content is not modified by this method
			issues,
			suggestions,
		};
	}

	/**
	 * Analyze file structure for modification context
	 */
	private async _analyzeFileStructure(
		filePath: string,
		content: string
	): Promise<FileStructureAnalysis> {
		const lines = content.split("\n");
		const structure: FileStructureAnalysis = {
			imports: [],
			exports: [],
			functions: [],
			classes: [],
			variables: [],
			comments: [],
		};

		for (let i = 0; i < lines.length; i++) {
			const line = lines[i].trim();

			if (line.startsWith("import ")) {
				structure.imports.push({ line: i + 1, content: line });
			} else if (line.startsWith("export ")) {
				structure.exports.push({ line: i + 1, content: line });
			} else if (line.includes("function ") || line.includes("=>")) {
				structure.functions.push({ line: i + 1, content: line });
			} else if (line.includes("class ")) {
				structure.classes.push({ line: i + 1, content: line });
			} else if (
				line.includes("const ") ||
				line.includes("let ") ||
				line.includes("var ")
			) {
				structure.variables.push({ line: i + 1, content: line });
			} else if (line.startsWith("//") || line.startsWith("/*")) {
				structure.comments.push({ line: i + 1, content: line });
			}
		}

		return structure;
	}

	/**
	 * Formats successful change sets into a concise string for AI prompts.
	 * Limits output to the last 3 change sets and 3 changes per set.
	 * @param changeSets An array of RevertibleChangeSet.
	 * @returns A formatted string summary of recent changes.
	 */
	private _formatSuccessfulChangesForPrompt(
		changeSets: RevertibleChangeSet[]
	): string {
		if (!changeSets || changeSets.length === 0) {
			return "";
		}

		const recentChangeSets = changeSets.slice(-3); // Get last 3 change sets
		let formattedHistory =
			"--- Recent Successful Project Changes (Context for AI) ---\n";

		for (const changeSet of recentChangeSets) {
			const date = new Date(changeSet.timestamp).toLocaleString();
			formattedHistory += `\n**Plan Executed on ${date} (ID: ${changeSet.id.substring(
				0,
				8
			)})**\n`;
			if (changeSet.planSummary) {
				// Changed from changeSet.summary
				formattedHistory += `Summary: ${changeSet.planSummary}\n`; // Changed from changeSet.summary
			}
			formattedHistory += `Changes:\n`;
			const limitedChanges = changeSet.changes.slice(0, 3); // Limit to last 3 changes per set
			for (const change of limitedChanges) {
				formattedHistory += `- **${change.changeType.toUpperCase()}**: \`${
					change.filePath
				}\` - ${change.summary.split("\n")[0]}\n`;
			}
			if (changeSet.changes.length > 3) {
				formattedHistory += `  ...and ${
					changeSet.changes.length - 3
				} more changes.\n`;
			}
		}
		formattedHistory += "\n--- End Recent Successful Project Changes ---\n";
		return formattedHistory;
	}

	/**
	 * Generate modification with enhanced context
	 */
	private async _generateModification(
		filePath: string,
		modificationPrompt: string,
		currentContent: string,
		context: EnhancedGenerationContext, // MODIFIED: fileAnalysis now part of context
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<string> {
		const enhancedPrompt = createEnhancedModificationPrompt(
			filePath,
			modificationPrompt,
			currentContent,
			context
		);

		try {
			const rawContent = await this.aiRequestService.generateWithRetry(
				[{ text: enhancedPrompt }], // Modified: Wrap prompt string in HistoryEntryPart array
				modelName,
				undefined,
				"enhanced file modification",
				undefined,
				{
					onChunk: async (chunk: string) => {
						this.postMessageToWebview({
							type: "codeFileStreamChunk",
							value: { streamId: streamId, filePath: filePath, chunk: chunk },
						});
						if (onCodeChunkCallback) {
							await onCodeChunkCallback(chunk);
						}
					},
				},
				token
			);
			return cleanCodeOutput(rawContent);
		} catch (error: any) {
			throw error;
		}
	}

	/**
	 * Validate and refine modification
	 */
	private async _validateAndRefineModification(
		filePath: string,
		originalContent: string,
		modifiedContent: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<CodeValidationResult> {
		const { addedLines, removedLines } = await generateFileChangeSummary(
			originalContent,
			modifiedContent,
			filePath // filePath is needed by generateFileChangeSummary for context
		);

		const noSubstantialChange =
			addedLines.length === 0 && removedLines.length === 0;

		if (noSubstantialChange) {
			// Generate a prompt specifically for this scenario
			const refineModificationPromptString = createRefinementPrompt(
				filePath,
				originalContent, // The content to refine, as modifiedContent yielded no changes.
				// Synthesize a CodeIssue object to represent the 'no substantial change' feedback.
				[
					{
						type: "other",
						message:
							"AI generated no substantial change. The proposed content is identical to the original or contains only cosmetic differences. A meaningful modification was expected.",
						line: 1, // A generic line number for a file-level issue.
						severity: "warning",
					},
				],
				context
			);

			// Call the AI service to get a refined output
			const rawRefinedContent = await this.aiRequestService.generateWithRetry(
				[{ text: refineModificationPromptString }], // Wrap prompt string in HistoryEntryPart array
				modelName,
				undefined, // history
				"refine modification (no substantial change)", // requestType label for monitoring
				undefined, // generationConfig
				{
					onChunk: async (chunk: string) => {
						// Handle streaming feedback
						this.postMessageToWebview({
							type: "codeFileStreamChunk",
							value: { streamId: streamId, filePath: filePath, chunk: chunk },
						});
						if (onCodeChunkCallback) {
							await onCodeChunkCallback(chunk);
						}
					},
				},
				token
			);

			const refinedContent = cleanCodeOutput(rawRefinedContent);

			// Re-validate the content produced by the refinement process
			const finalValidation = await this._validateCode(
				filePath,
				refinedContent
			);

			// Return the result of the re-validation
			return {
				isValid: finalValidation.isValid,
				finalContent: refinedContent,
				issues: finalValidation.issues,
				suggestions: finalValidation.suggestions,
			};
		}
		const diffAnalysis = this._analyzeDiff(originalContent, modifiedContent);

		if (diffAnalysis.isReasonable) {
			const validation = await this._validateCode(filePath, modifiedContent);
			return {
				isValid: validation.isValid,
				finalContent: modifiedContent,
				issues: validation.issues,
				suggestions: validation.suggestions,
			};
		}

		// If the modification seems unreasonable, try to refine it
		const refineModificationPromptString = createRefineModificationPrompt(
			filePath,
			originalContent,
			modifiedContent,
			diffAnalysis.issues,
			context
		);

		const rawRefinedContent = await this.aiRequestService.generateWithRetry(
			[{ text: refineModificationPromptString }],
			modelName,
			undefined,
			"refine modification",
			undefined,
			{
				onChunk: async (chunk: string) => {
					this.postMessageToWebview({
						type: "codeFileStreamChunk",
						value: { streamId: streamId, filePath: filePath, chunk: chunk },
					});
					if (onCodeChunkCallback) {
						await onCodeChunkCallback(chunk);
					}
				},
			},
			token
		);

		const refinedContent = cleanCodeOutput(rawRefinedContent);

		const finalValidation = await this._validateCode(filePath, refinedContent);

		return {
			isValid: finalValidation.isValid,
			finalContent: refinedContent,
			issues: finalValidation.issues,
			suggestions: finalValidation.suggestions,
		};
	}

	/**
	 * Analyze the diff between original and modified content
	 */
	private _analyzeDiff(original: string, modified: string): DiffAnalysis {
		const originalLines = original.split("\n");
		const modifiedLines = modified.split("\n");

		const issues: string[] = [];
		let isReasonable = true;

		// Check if the modification is too drastic
		const originalLength = originalLines.length;
		const modifiedLength = modifiedLines.length;
		const changeRatio =
			originalLength === 0
				? modifiedLength > 0
					? 1
					: 0
				: Math.abs(modifiedLength - originalLength) / originalLength;

		if (changeRatio > 0.8) {
			issues.push(
				"Modification seems too drastic - consider a more targeted approach"
			);
			isReasonable = false;
		}

		// Check if essential structure is preserved
		const originalImports = originalLines.filter((line) =>
			line.trim().startsWith("import")
		);
		const modifiedImports = modifiedLines.filter((line) =>
			line.trim().startsWith("import")
		);

		if (originalImports.length > 0 && modifiedImports.length === 0) {
			issues.push("All imports were removed - this may be incorrect");
			isReasonable = false;
		}

		return {
			isReasonable,
			issues,
			changeRatio,
		};
	}

	/**
	 * Original full file modification method (fallback)
	 */
	private async _modifyFileContentFull(
		filePath: string,
		modificationPrompt: string,
		currentContent: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<{ content: string; validation: CodeValidationResult }> {
		// Step 1: Analyze current file structure and dependencies
		const fileAnalysis = await this._analyzeFileStructure(
			filePath,
			currentContent
		);

		// MODIFIED: Create a new context object that includes fileStructureAnalysis and successfulChangeHistory
		const contextWithAllAnalysis: EnhancedGenerationContext = {
			...context,
			fileStructureAnalysis: fileAnalysis,
			successfulChangeHistory: this._formatSuccessfulChangesForPrompt(
				this.changeLogger.getCompletedPlanChangeSets()
			), // NEW: Populate history
		};

		// Step 2: Generate modification with enhanced context
		const modifiedContent = await this._generateModification(
			filePath,
			modificationPrompt,
			currentContent,
			contextWithAllAnalysis, // MODIFIED: Pass the new context object
			modelName,
			streamId,
			token,
			onCodeChunkCallback
		);

		// Step 3: Validate and refine the modification
		const validation = await this._validateAndRefineModification(
			filePath,
			currentContent,
			modifiedContent,
			contextWithAllAnalysis, // MODIFIED: Pass the new context object
			modelName,
			streamId,
			token,
			onCodeChunkCallback
		);

		return {
			content: validation.finalContent,
			validation: {
				...validation,
			},
		};
	}

	/**
	 * Heuristically determines if the AI's raw text output is likely an error message
	 * instead of valid code/content.
	 * @param content The raw string content generated by the AI.
	 * @returns True if the content is likely an error message, false otherwise.
	 */
	private _isAIOutputLikelyErrorMessage(content: string): boolean {
		const lowerContent = content.toLowerCase().trim();

		// Common phrases indicating an AI error or inability to perform a task
		const errorPhrases = [
			"i am sorry",
			"i'm sorry",
			"i cannot fulfill this request",
			"i encountered an error",
			"i ran into an issue",
			"an error occurred",
			"i am unable to provide",
			"please try again",
			"i couldn't generate",
			"i'm having trouble",
			"error:",
			"failure:",
			"exception:",
			"i can't",
			"i am not able to",
			"as an ai model", // Often precedes an explanation for not being able to do something
			"i lack the ability to",
			"insufficient information",
			"invalid request",
			"not enough context",
		];

		// Common system/API error phrases that might be passed through
		const systemErrorPhrases = [
			"access denied",
			"file not found",
			"permission denied",
			"timeout",
			"rate limit",
			"quota exceeded",
			"server error",
			"api error",
		];

		// Combine all phrases
		const allErrorPhrases = [...errorPhrases, ...systemErrorPhrases];

		if (allErrorPhrases.some((phrase) => lowerContent.includes(phrase))) {
			return true;
		}

		// Heuristic for very short content that looks like an "error"
		// E.g., if it's less than 200 characters and contains keywords like "error", "fail", "issue"
		if (
			content.length < 200 &&
			(lowerContent.includes("error") ||
				lowerContent.includes("fail") ||
				lowerContent.includes("issue"))
		) {
			return true;
		}

		// Safety net: check for markdown code blocks that explicitly contain error-like text.
		// This is for cases where markdown stripping might fail or AI incorrectly wraps an an error in a code block.
		const markdownErrorPattern =
			/(?:[a-zA-Z0-9]+)?\s*(error|fail|exception|apology|i am sorry)[\s\S]*?/i;
		if (markdownErrorPattern.test(content)) {
			return true;
		}

		return false;
	}

	/**
	 * Identifies issues present in `newIssues` that were not in `originalIssues`.
	 */
	private _getIssuesIntroduced(
		originalIssues: CodeIssue[],
		newIssues: CodeIssue[]
	): CodeIssue[] {
		const originalIssueSet = new Set<string>(
			originalIssues.map(getIssueIdentifier)
		);
		return newIssues.filter(
			(issue) => !originalIssueSet.has(getIssueIdentifier(issue))
		);
	}

	/**
	 * Detects if the AI is stuck in an oscillation (repeatedly failing to resolve similar issues).
	 * Checks `context.recentCorrectionAttemptOutcomes` for recurring similar issues.
	 * @param context The current enhanced generation context.
	 * @param currentIssuesCount The number of issues before the current failed correction attempt.
	 * @param correctedIssuesCount The number of issues after the current failed correction attempt.
	 * @returns `true` if an oscillation is detected, `false` otherwise.
	 */
	private async _detectOscillation(
		context: EnhancedGenerationContext,
		currentIssuesCount: number, // Not directly used in current simple logic, but can be for more complex heuristics
		correctedIssuesCount: number // Not directly used in current simple logic, but can be for more complex heuristics
	): Promise<boolean> {
		const recentOutcomes = context.recentCorrectionAttemptOutcomes;

		if (!recentOutcomes || recentOutcomes.length < 2) {
			return false; // Need at least two attempts to detect a pattern
		}

		// Check if the last two attempts both failed and left similar issues remaining
		const lastOutcome = recentOutcomes[recentOutcomes.length - 1];
		const secondLastOutcome = recentOutcomes[recentOutcomes.length - 2];

		if (
			!lastOutcome.success &&
			!secondLastOutcome.success &&
			areIssuesSimilar(
				lastOutcome.issuesRemaining,
				secondLastOutcome.issuesRemaining
			)
		) {
			// Basic oscillation detected: last two failed attempts left the same set of issues
			return true;
		}

		// More complex oscillation detection: e.g., if the issues count alternates but never resolves,
		// or if a specific issue consistently re-appears.
		// For now, the simple "same issues remaining after two failures" is sufficient.
		return false;
	}

	/**
	 * Generate content with real-time feedback loop
	 */
	private async _generateWithRealTimeFeedback(
		filePath: string,
		generatePrompt: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		feedbackCallback?: (feedback: RealTimeFeedback) => void,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<{ content: string; validation: CodeValidationResult }> {
		let currentContent = "";
		let iteration = 0;
		let totalIssues = 0;
		let resolvedIssues = 0;
		let currentValidation: CodeValidationResult; // This will hold the result of the last validation/correction attempt

		// Initialize context properties that will be updated in the loop
		let currentContext: EnhancedGenerationContext = {
			...context,
			lastFailedCorrectionDiff: undefined,
			successfulChangeHistory: this._formatSuccessfulChangesForPrompt(
				this.changeLogger.getCompletedPlanChangeSets()
			),
			lastCorrectionAttemptOutcome: undefined, // NEW: Initialize as undefined
			recentCorrectionAttemptOutcomes: [], // NEW: Initialize as empty array
			isOscillating: false, // NEW: Initialize as false
		};

		this._sendFeedback(feedbackCallback, {
			stage: "initialization",
			message: "Starting code generation with real-time validation...",
			issues: [],
			suggestions: [
				"Analyzing project context",
				"Preparing generation strategy",
			],
			progress: 0,
		});

		try {
			this._sendFeedback(feedbackCallback, {
				stage: "generation",
				message: "Generating initial code structure...",
				issues: [],
				suggestions: ["Creating file structure", "Adding imports"],
				progress: 20,
			});

			// Analyze file structure *before* initial content generation, as it's needed for the prompt
			currentContext.fileStructureAnalysis = await this._analyzeFileStructure(
				filePath,
				"" // Initial content is empty, so analysis is based on surrounding context/empty file.
			);

			// NEW: Get CodeValidationResult from _generateInitialContent
			currentValidation = await this._generateInitialContent(
				filePath,
				generatePrompt,
				currentContext, // Use updated context for initial generation
				modelName,
				streamId,
				token,
				onCodeChunkCallback
			);
			currentContent = currentValidation.finalContent;

			await DiagnosticService.waitForDiagnosticsToStabilize(
				vscode.Uri.file(filePath),
				token,
				5000,
				100
			);

			while (iteration < this.config.maxFeedbackIterations!) {
				if (token?.isCancellationRequested) {
					throw new Error("Operation cancelled");
				}

				iteration++;
				this._sendFeedback(feedbackCallback, {
					stage: "validation",
					message: `Validating code (iteration ${iteration}/${this.config.maxFeedbackIterations})...`,
					issues: [],
					suggestions: [
						"Checking syntax",
						"Validating imports",
						"Analyzing structure",
					],
					progress: 20 + iteration * 15,
				});

				const currentContentBeforeCorrectionAttempt = currentContent;

				// Always re-validate VS Code diagnostics for currentContent at the start of each loop iteration
				const diagnosticValidation = await this._validateCode(
					filePath,
					currentContent
				);

				// Combine current VS Code diagnostics with any format errors from the *previous* AI output
				let currentIssuesCombined: CodeIssue[] = [
					...diagnosticValidation.issues,
				];
				const prevFormatIssues = currentValidation.issues.filter(
					(i) => i.type === "format_error"
				);
				if (prevFormatIssues.length > 0) {
					// Add format issues to the front to prioritize them
					currentIssuesCombined.unshift(...prevFormatIssues);
				}

				// Update overall currentValidation for this iteration's starting state
				let hasCriticalError = currentIssuesCombined.some(
					(i) => i.severity === "error" || i.type === "format_error"
				);
				currentValidation = {
					isValid: !hasCriticalError,
					finalContent: currentContent,
					issues: currentIssuesCombined,
					suggestions: diagnosticValidation.suggestions,
				};

				const currentIssuesCount = currentValidation.issues.length;
				const formatErrorPresent = currentValidation.issues.some(
					(i) => i.type === "format_error"
				);

				// Always update file structure and successful change history for current context within the loop
				currentContext.fileStructureAnalysis = await this._analyzeFileStructure(
					filePath,
					currentContent
				);
				currentContext.successfulChangeHistory =
					this._formatSuccessfulChangesForPrompt(
						this.changeLogger.getCompletedPlanChangeSets()
					);

				// Refresh error-focused context if there are issues
				if (currentIssuesCount > 0) {
					currentContext = await this._refreshErrorFocusedContext(
						filePath,
						currentContent,
						currentValidation.issues, // Pass combined issues for context refresh
						currentContext,
						token
					);
				}

				if (currentIssuesCount === 0) {
					this._sendFeedback(feedbackCallback, {
						stage: "completion",
						message: "Code generation completed successfully!",
						issues: [],
						suggestions: currentValidation.suggestions,
						progress: 100,
					});

					currentContext.lastFailedCorrectionDiff = undefined; // Clear diff on success
					currentContext.lastCorrectionAttemptOutcome = undefined; // NEW: Clear outcome on success
					currentContext.recentCorrectionAttemptOutcomes = []; // NEW: Clear recent outcomes on success
					currentContext.isOscillating = false; // NEW: Clear oscillation status on success
					return {
						content: currentContent,
						validation: {
							...currentValidation,
							finalContent: currentContent,
							iterations: iteration,
							totalIssues: totalIssues,
							resolvedIssues: resolvedIssues,
						},
					};
				}

				totalIssues += currentIssuesCount;

				let correctionResult: CodeValidationResult;

				// NEW: Format error correction takes precedence
				if (formatErrorPresent) {
					this._sendFeedback(feedbackCallback, {
						stage: "format_correction",
						message: `Detected critical format error, attempting to enforce pure code output within delimiters...`,
						issues: currentValidation.issues,
						suggestions: [
							"Ensuring BEGIN_CODE/END_CODE delimiters",
							"Removing conversational text",
						],
						progress: 20 + iteration * 15,
					});

					const pureCodePromptString = createPureCodeFormatCorrectionPrompt(
						filePath,
						currentContent, // The current problematic content
						currentContext // Pass current context
					);

					const rawFormatCorrectedContent =
						await this.aiRequestService.generateWithRetry(
							[{ text: pureCodePromptString }],
							modelName,
							undefined,
							"pure code format correction",
							undefined,
							{
								onChunk: async (chunk: string) => {
									this.postMessageToWebview({
										type: "codeFileStreamChunk",
										value: {
											streamId: streamId,
											filePath: filePath,
											chunk: chunk,
										},
									});
									if (onCodeChunkCallback) {
										await onCodeChunkCallback(chunk);
									}
								},
							},
							token
						);

					// Immediately validate the *format* of this new response
					correctionResult = this._checkPureCodeFormat(
						rawFormatCorrectedContent
					);
				} else {
					// No format error, proceed with regular corrections
					this._sendFeedback(feedbackCallback, {
						stage: "correction",
						message: `Found ${currentIssuesCount} VS Code-reported compilation/linting issues, applying corrections...`,
						issues: currentValidation.issues,
						suggestions: [
							"Fixing syntax errors",
							"Correcting imports",
							"Improving structure",
						],
						progress: 20 + iteration * 15,
					});

					// MODIFIED: _applyRealTimeCorrections now returns CodeValidationResult
					correctionResult = await this._applyRealTimeCorrections(
						filePath,
						currentContent,
						currentValidation.issues, // Pass combined issues from previous validation
						currentContext, // Pass updated context (potentially refreshed)
						modelName,
						streamId,
						token,
						onCodeChunkCallback
					);
				}

				// Update currentContent for subsequent validation/iteration
				currentContent = correctionResult.finalContent;

				await DiagnosticService.waitForDiagnosticsToStabilize(
					vscode.Uri.file(filePath),
					token,
					5000,
					100
				);

				// Re-validate the content after the current correction attempt (either format or regular)
				const correctedDiagnosticValidation = await this._validateCode(
					filePath,
					currentContent
				);

				// Merge format issues from the `correctionResult` with the new diagnostic issues
				const issuesAfterAttemptCombined: CodeIssue[] = [
					...correctedDiagnosticValidation.issues,
				];
				const newFormatIssues = correctionResult.issues.filter(
					(i) => i.type === "format_error"
				);
				if (newFormatIssues.length > 0) {
					issuesAfterAttemptCombined.unshift(...newFormatIssues); // Add to front
				}

				const issuesAfterAttemptCount = issuesAfterAttemptCombined.length;

				// Determine if there was an improvement (fewer issues overall)
				// An improvement also means fixing a format error, even if diagnostic issues remain the same.
				const wasImprovement =
					issuesAfterAttemptCount < currentIssuesCount ||
					(issuesAfterAttemptCount === 0 && currentIssuesCount > 0);

				if (wasImprovement) {
					resolvedIssues += currentIssuesCount - issuesAfterAttemptCount;
					// Clear all oscillation/failure tracking as there was an improvement
					currentContext.lastFailedCorrectionDiff = undefined;
					currentContext.lastCorrectionAttemptOutcome = undefined;
					currentContext.recentCorrectionAttemptOutcomes = [];
					currentContext.isOscillating = false;

					this._sendFeedback(feedbackCallback, {
						stage: "improvement",
						message: `Resolved ${
							currentIssuesCount - issuesAfterAttemptCount
						} issues (${issuesAfterAttemptCount} remaining)...`,
						issues: issuesAfterAttemptCombined,
						suggestions: correctedDiagnosticValidation.suggestions,
						progress: 20 + iteration * 15,
					});
					// Update currentValidation for the next loop iteration (important!)
					currentValidation = {
						isValid: !issuesAfterAttemptCombined.some(
							(i) => i.severity === "error" || i.type === "format_error"
						),
						finalContent: currentContent,
						issues: issuesAfterAttemptCombined,
						suggestions: correctedDiagnosticValidation.suggestions,
					};
				} else {
					// No improvement or made things worse, capture diff and try alternative approach
					// Determine issues introduced by this specific attempt
					const issuesIntroduced = this._getIssuesIntroduced(
						currentValidation.issues, // issues before this attempt (including format errors if any)
						issuesAfterAttemptCombined // issues after this attempt (including format errors if any)
					);

					// Determine failure type based on issue counts and format status
					let failureType: CorrectionAttemptOutcome["failureType"];
					if (newFormatIssues.length > 0) {
						// If format error was introduced or persists
						failureType = "parsing_failed"; // Signifies inability to parse/extract pure code
					} else if (issuesAfterAttemptCount > currentIssuesCount) {
						failureType = "new_errors_introduced";
					} else {
						failureType = "no_improvement";
					}

					// Create CorrectionAttemptOutcome for the current failed attempt
					const currentFailedOutcome: CorrectionAttemptOutcome = {
						success: false, // Since no improvement or worse
						iteration: iteration,
						originalIssuesCount: currentIssuesCount,
						issuesAfterAttemptCount: issuesAfterAttemptCount,
						issuesRemaining: issuesAfterAttemptCombined,
						issuesIntroduced: issuesIntroduced,
						relevantDiff: "", // Will be populated by createAIFailureAnalysisPrompt
						aiFailureAnalysis: "", // Will be filled below
						failureType: failureType,
					};

					// Initialize recentCorrectionAttemptOutcomes if it doesn't exist
					if (!currentContext.recentCorrectionAttemptOutcomes) {
						currentContext.recentCorrectionAttemptOutcomes = [];
					}
					// Add the current failed outcome to the history
					currentContext.recentCorrectionAttemptOutcomes.push(
						currentFailedOutcome
					);
					// Trim the history to the fixed size
					if (
						currentContext.recentCorrectionAttemptOutcomes.length >
						this.MAX_OSCILLATION_HISTORY_SIZE
					) {
						currentContext.recentCorrectionAttemptOutcomes.shift();
					}

					// Detect oscillation based on the updated history
					currentContext.isOscillating = await this._detectOscillation(
						currentContext,
						currentIssuesCount,
						issuesAfterAttemptCount
					);

					// NEW: Refresh error-focused context again before alternative corrections
					const contextForAlternative = await this._refreshErrorFocusedContext(
						filePath,
						currentContent, // Use currentContent for refreshing context as it's the current state
						issuesAfterAttemptCombined, // Use the combined issues after the correction attempt
						currentContext, // Pass the currentContext which now includes oscillation status and recent outcomes
						token
					);
					currentContext = contextForAlternative; // Crucially update currentContext

					// Generate AI failure analysis, passing current context details including oscillation status
					const aiFailureAnalysisPromptString = createAIFailureAnalysisPrompt(
						filePath,
						currentContentBeforeCorrectionAttempt,
						currentContent, // Pass the content *after* the failed correction
						currentValidation.issues, // Issues before this attempt (including format)
						issuesAfterAttemptCombined, // Issues after this attempt (including format)
						iteration,
						currentContext.recentCorrectionAttemptOutcomes,
						currentContext.isOscillating
					);

					const rawAiFailureAnalysis: string =
						await this.aiRequestService.generateWithRetry(
							[{ text: await aiFailureAnalysisPromptString }],
							modelName,
							undefined,
							"AI failure analysis",
							undefined,
							undefined, // No streaming expected for this specific prompt type
							token
						);
					const aiFailureAnalysis = cleanCodeOutput(rawAiFailureAnalysis); // Clean AI response

					// Update the currentFailedOutcome with the generated analysis
					currentFailedOutcome.aiFailureAnalysis = aiFailureAnalysis;
					// Update relevant diff in outcome object. The prompt now uses generateFileChangeSummary internally.
					const { formattedDiff } = await generateFileChangeSummary(
						currentContentBeforeCorrectionAttempt,
						currentContent,
						filePath
					);
					currentFailedOutcome.relevantDiff = formattedDiff;

					// Assign the fully populated outcome to lastCorrectionAttemptOutcome
					currentContext.lastCorrectionAttemptOutcome = currentFailedOutcome;

					// Set lastFailedCorrectionDiff to undefined as new outcome object replaces its function
					currentContext.lastFailedCorrectionDiff = undefined;

					this._sendFeedback(feedbackCallback, {
						stage: "alternative",
						message:
							"Correction did not improve the situation, trying alternative approach...",
						issues: issuesAfterAttemptCombined,
						suggestions: ["Using different strategy", "Analyzing patterns"],
						progress: 20 + iteration * 15,
					});

					const alternativeCorrectionPromptString =
						createAlternativeCorrectionPrompt(
							filePath,
							currentContent,
							issuesAfterAttemptCombined, // Issues that remain
							currentContext
						);

					const rawAlternativeContent =
						await this.aiRequestService.generateWithRetry(
							[{ text: alternativeCorrectionPromptString }],
							modelName,
							undefined,
							"alternative correction",
							undefined,
							{
								onChunk: async (chunk: string) => {
									this.postMessageToWebview({
										type: "codeFileStreamChunk",
										value: {
											streamId: streamId,
											filePath: filePath,
											chunk: chunk,
										},
									});
									if (onCodeChunkCallback) {
										await onCodeChunkCallback(chunk);
									}
								},
							},
							token
						);

					// Validate the alternative content's format
					const alternativeFormatValidation = this._checkPureCodeFormat(
						rawAlternativeContent
					);
					currentContent = alternativeFormatValidation.finalContent; // Use the formatted content

					await DiagnosticService.waitForDiagnosticsToStabilize(
						vscode.Uri.file(filePath),
						token,
						5000,
						100
					);

					// Re-validate for diagnostics after alternative
					const alternativeDiagnosticValidation = await this._validateCode(
						filePath,
						currentContent
					);

					// Combine alternative diagnostic validation with any format issues from alternative attempt
					const alternativeIssuesCombined: CodeIssue[] = [
						...alternativeDiagnosticValidation.issues,
					];
					if (!alternativeFormatValidation.isValid) {
						alternativeIssuesCombined.unshift(
							...alternativeFormatValidation.issues
						);
					}

					// Check if alternative attempt provided improvement
					if (
						alternativeIssuesCombined.length < issuesAfterAttemptCount ||
						(alternativeIssuesCombined.length === 0 &&
							issuesAfterAttemptCount > 0)
					) {
						// Improvement occurred
						currentValidation = {
							// Update currentValidation for next iteration
							isValid: !alternativeIssuesCombined.some(
								(i) => i.severity === "error" || i.type === "format_error"
							),
							finalContent: currentContent,
							issues: alternativeIssuesCombined,
							suggestions: alternativeDiagnosticValidation.suggestions,
						};
						resolvedIssues +=
							issuesAfterAttemptCount - alternativeIssuesCombined.length;
						currentContext.lastFailedCorrectionDiff = undefined;
						currentContext.lastCorrectionAttemptOutcome = undefined;
						currentContext.recentCorrectionAttemptOutcomes = [];
						currentContext.isOscillating = false;
					} else {
						// Still no improvement with alternative approach, break loop
						this._sendFeedback(feedbackCallback, {
							stage: "revert",
							message:
								"Alternative correction failed or made issues worse. Stopping automatic corrections.",
							issues: alternativeIssuesCombined, // Show current issues
							suggestions: [
								"Manual review recommended",
								"Consider providing more context",
							],
							progress: 20 + iteration * 15,
						});
						break; // Break to avoid infinite loop
					}
				}
			}

			// Final validation after loop exits
			// `currentValidation` already holds the final state from the last iteration.
			// Ensure all counts are updated.
			currentValidation.iterations = iteration;
			currentValidation.totalIssues = totalIssues;
			currentValidation.resolvedIssues = resolvedIssues;

			this._sendFeedback(feedbackCallback, {
				stage: "final",
				message: `Code generation completed with ${currentValidation.issues.length} remaining issues`,
				issues: currentValidation.issues,
				suggestions: currentValidation.suggestions,
				progress: 100,
			});

			return {
				content: currentContent,
				validation: currentValidation,
			};
		} catch (error) {
			this._sendFeedback(feedbackCallback, {
				stage: "error",
				message: `Code generation failed: ${
					error instanceof Error ? error.message : String(error)
				}`,
				issues: [],
				suggestions: [
					"Check error details in output",
					"Try again with different approach",
				],
				progress: 100,
			});

			throw error;
		}
	}

	/**
	 * Apply real-time corrections based on validation issues
	 */
	private async _applyRealTimeCorrections(
		filePath: string,
		content: string,
		issues: CodeIssue[],
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<CodeValidationResult> {
		// MODIFIED: Return CodeValidationResult
		const syntaxIssues = issues.filter((i) => i.type === "syntax");
		const importIssues = issues.filter((i) => i.type === "unused_import");
		const bestPracticeIssues = issues.filter((i) => i.type === "best_practice");
		const securityIssues = issues.filter((i) => i.type === "security");
		const otherIssues = issues.filter((i) => i.type === "other");

		let currentCorrectedContent = content; // Start with the current content
		// const languageId = getLanguageId(path.extname(filePath)); // Get languageId once, not used directly here

		// Apply corrections in order of priority
		if (syntaxIssues.length > 0) {
			const syntaxCorrectionPromptString = createSyntaxCorrectionPrompt(
				filePath,
				currentCorrectedContent,
				syntaxIssues,
				context
			);

			const rawSyntaxCorrection = await this.aiRequestService.generateWithRetry(
				[{ text: syntaxCorrectionPromptString }],
				modelName,
				undefined,
				"syntax correction",
				undefined,
				{
					onChunk: async (chunk: string) => {
						this.postMessageToWebview({
							type: "codeFileStreamChunk",
							value: { streamId: streamId, filePath: filePath, chunk: chunk },
						});
						if (onCodeChunkCallback) {
							await onCodeChunkCallback(chunk);
						}
					},
				},
				token
			);
			// NEW: Call _checkPureCodeFormat on the raw response
			const syntaxFormatValidation =
				this._checkPureCodeFormat(rawSyntaxCorrection);
			if (!syntaxFormatValidation.isValid) {
				return syntaxFormatValidation; // Critical format error, propagate immediately
			}
			currentCorrectedContent = syntaxFormatValidation.finalContent;
		}

		if (token?.isCancellationRequested) {
			return {
				isValid: false,
				finalContent: currentCorrectedContent,
				issues: [
					{
						type: "other",
						message: "Operation cancelled",
						line: 1,
						severity: "info",
					},
				],
				suggestions: [],
			};
		}

		if (importIssues.length > 0) {
			const importCorrectionPromptString = createImportCorrectionPrompt(
				filePath,
				currentCorrectedContent,
				importIssues,
				context
			);

			const rawImportCorrection = await this.aiRequestService.generateWithRetry(
				[{ text: importCorrectionPromptString }],
				modelName,
				undefined,
				"import correction",
				undefined,
				{
					onChunk: async (chunk: string) => {
						this.postMessageToWebview({
							type: "codeFileStreamChunk",
							value: { streamId: streamId, filePath: filePath, chunk: chunk },
						});
						if (onCodeChunkCallback) {
							await onCodeChunkCallback(chunk);
						}
					},
				},
				token
			);
			// NEW: Call _checkPureCodeFormat on the raw response
			const importFormatValidation =
				this._checkPureCodeFormat(rawImportCorrection);
			if (!importFormatValidation.isValid) {
				return importFormatValidation; // Critical format error, propagate immediately
			}
			currentCorrectedContent = importFormatValidation.finalContent;
		}

		if (token?.isCancellationRequested) {
			return {
				isValid: false,
				finalContent: currentCorrectedContent,
				issues: [
					{
						type: "other",
						message: "Operation cancelled",
						line: 1,
						severity: "info",
					},
				],
				suggestions: [],
			};
		}

		// Combine best_practice and general 'other' issues, as they might stem from general diagnostics
		const combinedPracticeAndOtherIssues = [
			...bestPracticeIssues,
			...otherIssues,
		];
		if (combinedPracticeAndOtherIssues.length > 0) {
			const practiceCorrectionPromptString = createPracticeCorrectionPrompt(
				filePath,
				currentCorrectedContent,
				combinedPracticeAndOtherIssues,
				context
			);

			const rawPracticeCorrection =
				await this.aiRequestService.generateWithRetry(
					[{ text: practiceCorrectionPromptString }],
					modelName,
					undefined,
					"practice correction",
					undefined,
					{
						onChunk: async (chunk: string) => {
							this.postMessageToWebview({
								type: "codeFileStreamChunk",
								value: { streamId: streamId, filePath: filePath, chunk: chunk },
							});
							if (onCodeChunkCallback) {
								await onCodeChunkCallback(chunk);
							}
						},
					},
					token
				);
			// NEW: Call _checkPureCodeFormat on the raw response
			const practiceFormatValidation = this._checkPureCodeFormat(
				rawPracticeCorrection
			);
			if (!practiceFormatValidation.isValid) {
				return practiceFormatValidation; // Critical format error, propagate immediately
			}
			currentCorrectedContent = practiceFormatValidation.finalContent;
		}

		if (token?.isCancellationRequested) {
			return {
				isValid: false,
				finalContent: currentCorrectedContent,
				issues: [
					{
						type: "other",
						message: "Operation cancelled",
						line: 1,
						severity: "info",
					},
				],
				suggestions: [],
			};
		}

		// Explicitly call _correctSecurityIssues, even if securityIssues array is empty based on current _validateCode mapping
		if (securityIssues.length > 0) {
			// Keep this check, though it might be empty
			const securityCorrectionPromptString = createSecurityCorrectionPrompt(
				filePath,
				currentCorrectedContent,
				securityIssues,
				context
			);

			const rawSecurityCorrection =
				await this.aiRequestService.generateWithRetry(
					[{ text: securityCorrectionPromptString }],
					modelName,
					undefined,
					"security correction",
					undefined,
					{
						onChunk: async (chunk: string) => {
							this.postMessageToWebview({
								type: "codeFileStreamChunk",
								value: { streamId: streamId, filePath: filePath, chunk: chunk },
							});
							if (onCodeChunkCallback) {
								await onCodeChunkCallback(chunk);
							}
						},
					},
					token
				);
			// NEW: Call _checkPureCodeFormat on the raw response
			const securityFormatValidation = this._checkPureCodeFormat(
				rawSecurityCorrection
			);
			if (!securityFormatValidation.isValid) {
				return securityFormatValidation; // Critical format error, propagate immediately
			}
			currentCorrectedContent = securityFormatValidation.finalContent;
		}

		if (token?.isCancellationRequested) {
			return {
				isValid: false,
				finalContent: currentCorrectedContent,
				issues: [
					{
						type: "other",
						message: "Operation cancelled",
						line: 1,
						severity: "info",
					},
				],
				suggestions: [],
			};
		}

		// Re-validate after all primary corrections, then return the result
		return await this._validateCode(filePath, currentCorrectedContent);
	}

	/**
	 * Send feedback to callback if provided
	 */
	private _sendFeedback(
		callback?: (feedback: RealTimeFeedback) => void,
		feedback?: RealTimeFeedback
	): void {
		if (callback && feedback) {
			try {
				callback(feedback);
			} catch (error) {
				console.warn("Error in feedback callback:", error);
			}
		}
	}

	/**
	 * Heuristically determines if the user's prompt indicates an intent for a major rewrite or overhaul.
	 * @param prompt The user's input prompt string.
	 * @param filePath The path of the file being generated/modified (optional, for file-specific keywords).
	 * @returns True if rewrite intent is detected, false otherwise.
	 */
	private _isRewriteIntentDetected(prompt: string, filePath?: string): boolean {
		const lowerPrompt = prompt.toLowerCase();
		const rewriteKeywords = [
			"rewrite",
			"replace entirely",
			"generate from scratch",
			"completely change",
			"full overhaul",
			"start fresh",
			"reimplement",
			"rebuild",
			"design from scratch",
			"new implementation",
			"complete refactor",
		];

		// Check for general rewrite keywords
		if (rewriteKeywords.some((keyword) => lowerPrompt.includes(keyword))) {
			return true;
		}

		// Check for specific "completely change file X" pattern
		if (filePath) {
			const fileBaseName = path.basename(filePath).toLowerCase();
			if (
				lowerPrompt.includes(`completely change file ${fileBaseName}`) ||
				lowerPrompt.includes(`completely change this file`) ||
				lowerPrompt.includes(`rewrite file ${fileBaseName}`) ||
				lowerPrompt.includes(`rewrite this file`)
			) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Formats contents of selected file URIs into Markdown fenced code blocks.
	 * Includes error handling for unreadable or binary files and checks for cancellation.
	 * @param fileUris Nested arrays of vscode.Uri objects for the files to format.
	 * @param token A CancellationToken to observe cancellation requests.
	 * @returns A single concatenated string of all formatted snippets.
	 */
	private async _formatSelectedFilesIntoSnippets(
		fileUris: vscode.Uri[],
		token: vscode.CancellationToken
	): Promise<string> {
		if (!fileUris || fileUris.length === 0) {
			return "";
		}

		const formattedSnippets: string[] = [];
		// 1MB limit per file to prevent prompt overflow
		const maxFileSizeForSnippet = 1024 * 1024 * 1;

		for (const fileUri of fileUris) {
			if (token.isCancellationRequested) {
				return formattedSnippets.join("\n"); // Return what's processed so far
			}

			const relativePath = path
				.relative(this.workspaceRoot.fsPath, fileUri.fsPath)
				.replace(/\\/g, "/");
			let fileContent: string | null = null;
			let languageId = path.extname(fileUri.fsPath).substring(1);

			if (!languageId) {
				// Fallback for files without extension (e.g., Dockerfile, LICENSE)
				languageId = path.basename(fileUri.fsPath).toLowerCase();
			}
			// Special handling for common files without extensions where syntax highlighting is helpful
			if (languageId === "makefile") {
				languageId = "makefile";
			} else if (languageId === "dockerfile") {
				languageId = "dockerfile";
			} else if (languageId === "jsonc") {
				languageId = "json";
			} else if (languageId === "eslintignore") {
				languageId = "ignore";
			} else if (languageId === "prettierignore") {
				languageId = "ignore";
			} else if (languageId === "gitignore") {
				languageId = "ignore";
			} else if (languageId === "license") {
				languageId = "plaintext";
			}

			try {
				const fileStat = await vscode.workspace.fs.stat(fileUri);

				// Skip directories
				if (fileStat.type === vscode.FileType.Directory) {
					continue;
				}

				// Skip files larger than maxFileSizeForSnippet
				if (fileStat.size > maxFileSizeForSnippet) {
					console.warn(
						`[MinovativeMind] Skipping relevant file '${relativePath}' (size: ${fileStat.size} bytes) due to size limit for prompt inclusion.`
					);
					formattedSnippets.push(
						`--- Relevant File: ${relativePath} ---\n\`\`\`plaintext\n[File skipped: too large for context (${(
							fileStat.size / 1024
						).toFixed(2)}KB > ${(maxFileSizeForSnippet / 1024).toFixed(
							2
						)}KB)]\n\`\`\`\n`
					);
					continue;
				}

				const contentBuffer = await vscode.workspace.fs.readFile(fileUri);
				const content = Buffer.from(contentBuffer).toString("utf8");

				// Basic heuristic for binary files: check for null characters
				if (content.includes("\0")) {
					console.warn(
						`[MinovativeMind] Skipping relevant file '${relativePath}' as it appears to be binary.`
					);
					formattedSnippets.push(
						`--- Relevant File: ${relativePath} ---\n\`\`\`plaintext\n[File skipped: appears to be binary]\n\`\`\`\n`
					);
					continue;
				}

				fileContent = content;
			} catch (error: any) {
				if (
					error instanceof vscode.FileSystemError &&
					(error.code === "FileNotFound" || error.code === "EntryNotFound")
				) {
					console.warn(
						`[MinovativeMind] Relevant file not found: '${relativePath}'. Skipping.`
					);
				} else if (error.message.includes("is not a file")) {
					// This can happen if fileUri points to a directory
					console.warn(
						`[MinovativeMind] Skipping directory '${relativePath}' as a relevant file.`
					);
				} else {
					console.error(
						`[MinovativeMind] Error reading relevant file '${relativePath}': ${error.message}. Skipping.`,
						error
					);
				}
				formattedSnippets.push(
					`--- Relevant File: ${relativePath} ---\n\`\`\`plaintext\n[File skipped: could not be read or is inaccessible: ${error.message}]\n\`\`\`\n`
				);
				continue; // Skip to next file
			}

			if (fileContent !== null) {
				formattedSnippets.push(
					`--- Relevant File: ${relativePath} ---\n\`\`\`${languageId}\n${fileContent}\n\`\`\`\n`
				);
			}
		}

		return formattedSnippets.join("\n");
	}

	/**
	 * Refreshes the EnhancedGenerationContext with an error-focused perspective,
	 * rebuilding project context primarily based on current issues.
	 * @param filePath The path of the file currently being processed.
	 * @param currentContent The current content of the file.
	 * @param currentIssues A list of code issues reported for the current content.
	 * @param currentContext The existing EnhancedGenerationContext.
	 * @param token An optional cancellation token.
	 * @returns A new, refreshed EnhancedGenerationContext focused on the errors, or the original context if no issues or an error occurs.
	 */
	private async _refreshErrorFocusedContext(
		filePath: string,
		currentContent: string,
		currentIssues: CodeIssue[],
		currentContext: EnhancedGenerationContext,
		token?: vscode.CancellationToken
	): Promise<EnhancedGenerationContext> {
		if (currentIssues.length === 0) {
			return currentContext;
		}

		try {
			const languageId = getLanguageId(path.extname(filePath));
			const documentUri = vscode.Uri.file(filePath);

			// Construct a minimal editor context for refresh, assuming no specific selection is needed
			// as we are focusing on general file-level issues.
			const editorContextForRefresh = {
				filePath: filePath,
				fullText: currentContent,
				languageId: languageId,
				documentUri: documentUri,
				// A minimal range to satisfy the type, as no specific selection is tied to all issues
				selection: new vscode.Range(0, 0, 0, 0),
				instruction: "",
				selectedText: "",
			};

			// Format currentIssues into a focused diagnostic string for context building
			const formattedDiagnosticsString = formatGroupedIssuesForPrompt(
				groupAndPrioritizeIssues(
					currentIssues,
					this.issueTypeOrder,
					this.severityOrder
				),
				languageId,
				currentContent,
				this.issueTypeOrder,
				this.severityOrder,
				getCodeSnippet
			);

			// Call contextService.buildProjectContext with the formatted diagnostics
			const refreshResult = await this.contextService.buildProjectContext(
				token,
				undefined, // userRequest is not applicable for error-focused refresh
				editorContextForRefresh,
				formattedDiagnosticsString,
				{ useAISelectionCache: false, enablePerformanceMonitoring: false },
				false, // explicitly disable persona for code generation tasks
				false // includeVerboseHeaders
			);

			// Convert relevant file paths (strings) to URIs
			const relevantFileUris = refreshResult.relevantFiles.map((rfPath) =>
				vscode.Uri.joinPath(this.workspaceRoot, rfPath)
			);

			// Declare effectiveToken
			const effectiveToken =
				token ?? new vscode.CancellationTokenSource().token;

			// Format the contents of relevant files into snippets
			const relevantSnippetsContent =
				await this._formatSelectedFilesIntoSnippets(
					relevantFileUris,
					effectiveToken
				);

			// Create newEnhancedGenerationContext inheriting from currentContext
			// and updating relevant parts from refreshResult.
			const newEnhancedGenerationContext: EnhancedGenerationContext = {
				...currentContext,
				projectContext: refreshResult.contextString,
				relevantFiles: refreshResult.relevantFiles.join("\n"), // relevantFiles is string[] in BuildProjectContextResult
				relevantSnippets: relevantSnippetsContent, // Assign the formatted snippets
				activeSymbolInfo: refreshResult.activeSymbolDetailedInfo,
				// Ensure successfulChangeHistory is also updated if necessary
				successfulChangeHistory: this._formatSuccessfulChangesForPrompt(
					this.changeLogger.getCompletedPlanChangeSets()
				),
			};

			return newEnhancedGenerationContext;
		} catch (error: any) {
			console.error(
				`[EnhancedCodeGenerator] Error refreshing error-focused context for ${filePath}:`,
				error
			);
			// Log the issue and return the original context to prevent interruption
			return currentContext;
		}
	}
}
