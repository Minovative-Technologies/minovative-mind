import * as vscode from "vscode";
import * as path from "path";
import * as crypto from "crypto";
import { AIRequestService } from "../services/aiRequestService";
import { ActiveSymbolDetailedInfo } from "../services/contextService";
import { cleanCodeOutput } from "../utils/codeUtils";
import { DiagnosticService, getSeverityName } from "../utils/diagnosticUtils";
import { generateFileChangeSummary } from "../utils/diffingUtils";
import { ExtensionToWebviewMessages } from "../sidebar/common/sidebarTypes";
import { ProjectChangeLogger } from "../workflow/ProjectChangeLogger";
import { RevertibleChangeSet } from "../types/workflow";

/**
 * Real-time feedback interface for code generation
 */
interface RealTimeFeedback {
	stage: string;
	message: string;
	issues: CodeIssue[];
	suggestions: string[];
	progress: number; // 0-100
}

export interface CodeValidationResult {
	isValid: boolean;
	finalContent: string;
	issues: CodeIssue[];
	suggestions: string[];
	iterations?: number;
	totalIssues?: number;
	resolvedIssues?: number;
}

export interface CodeIssue {
	type: "syntax" | "unused_import" | "best_practice" | "security" | "other";
	message: string;
	line: number;
	severity: "error" | "warning" | "info";
	code?: string | number; // MODIFIED: Add code property
}

export interface FileAnalysis {
	framework: string;
	projectStructure: string;
	expectedPatterns: string;
	fileName: string;
	extension: string;
}

export interface FileStructureAnalysis {
	imports: Array<{ line: number; content: string }>;
	exports: Array<{ line: number; content: string }>;
	functions: Array<{ line: number; content: string }>;
	classes: Array<{ line: number; content: string }>;
	variables: Array<{ line: number; content: string }>;
	comments: Array<{ line: number; content: string }>;
}

export interface DiffAnalysis {
	isReasonable: boolean;
	issues: string[];
	changeRatio: number;
}

/**
 * Encapsulates details about a single correction attempt that did not yield the desired result.
 */
export interface CorrectionAttemptOutcome {
	success: boolean; // Indicates whether the correction attempt resulted in an improvement or at least maintained the status quo
	iteration: number; // The specific iteration number within the _generateWithRealTimeFeedback loop
	originalIssuesCount: number; // The number of issues identified before this correction attempt
	issuesAfterAttemptCount: number; // The number of issues identified after this correction attempt
	issuesRemaining: CodeIssue[]; // A list of CodeIssue objects that were still present after the attempt
	issuesIntroduced: CodeIssue[]; // A list of *new* CodeIssue objects introduced by this attempt
	relevantDiff: string; // The generated code diff representing the changes made in this attempt
	aiFailureAnalysis: string; // The crucial textual diagnosis generated by the AI itself, explaining *why* it believes the attempt failed
	failureType:
		| "no_improvement"
		| "new_errors_introduced"
		| "parsing_failed"
		| "unreasonable_diff"
		| "command_failed"
		| "unknown"; // A categorical reason for the failure
}

// NEW: Define EnhancedGenerationContext interface
export interface EnhancedGenerationContext {
	projectContext: string;
	relevantSnippets: string;
	editorContext?: any;
	activeSymbolInfo?: ActiveSymbolDetailedInfo;
	fileStructureAnalysis?: FileStructureAnalysis;
	lastFailedCorrectionDiff?: string;
	successfulChangeHistory?: string; // NEW: Added property
	lastCorrectionAttemptOutcome?: CorrectionAttemptOutcome; // NEW: Added property
	recentCorrectionAttemptOutcomes?: CorrectionAttemptOutcome[]; // NEW: Added property
	isOscillating?: boolean; // NEW: Added property
}

/**
 * Enhanced code generation with improved accuracy through:
 * 1. Better context analysis
 * 2. Code validation and refinement
 * 3. Dependency analysis
 * 4. Style consistency enforcement
 * 5. Error prevention
 * 6. Inline edit support for precise modifications
 * 7. Real-time feedback loop for immediate validation
 */
export class EnhancedCodeGenerator {
	// NEW: Define issue ordering constants
	private readonly issueTypeOrder: CodeIssue["type"][] = [
		"syntax",
		"unused_import",
		"security",
		"best_practice",
		"other",
	];
	private readonly severityOrder: CodeIssue["severity"][] = [
		"error",
		"warning",
		"info",
	];

	private readonly MAX_OSCILLATION_HISTORY_SIZE = 3; // Number of recent failed attempts to keep in context for oscillation detection

	constructor(
		private aiRequestService: AIRequestService,
		private workspaceRoot: vscode.Uri,
		private postMessageToWebview: (message: ExtensionToWebviewMessages) => void,
		private changeLogger: ProjectChangeLogger, // MODIFIED: Add changeLogger parameter
		private config: {
			enableRealTimeFeedback?: boolean;
			maxFeedbackIterations?: number;
		} = {}
	) {
		// Set defaults
		this.config.enableRealTimeFeedback =
			this.config.enableRealTimeFeedback ?? true;
		this.config.maxFeedbackIterations = this.config.maxFeedbackIterations ?? 5;
	}

	/**
	 * Enhanced file content generation with real-time feedback loop
	 */
	public async generateFileContent(
		filePath: string,
		generatePrompt: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		token?: vscode.CancellationToken,
		feedbackCallback?: (feedback: RealTimeFeedback) => void,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<{ content: string; validation: CodeValidationResult }> {
		const languageId = this._getLanguageId(path.extname(filePath));
		const streamId = crypto.randomUUID();

		this.postMessageToWebview({
			type: "codeFileStreamStart",
			value: { streamId: streamId, filePath: filePath, languageId: languageId },
		});

		try {
			if (this.config.enableRealTimeFeedback) {
				const result = await this._generateWithRealTimeFeedback(
					filePath,
					generatePrompt,
					context,
					modelName,
					streamId,
					token,
					feedbackCallback,
					onCodeChunkCallback
				);
				this.postMessageToWebview({
					type: "codeFileStreamEnd",
					value: { streamId: streamId, filePath: filePath, success: true },
				});
				return result;
			} else {
				// Non-real-time feedback path also needs initial context setup.
				// This branch is rarely used in practice with `enableRealTimeFeedback` typically true.
				const fileStructureAnalysis = await this._analyzeFileStructure(
					filePath,
					"" // Pass empty string as content is not yet generated
				);
				const successfulChangeHistory = this._formatSuccessfulChangesForPrompt(
					this.changeLogger.getCompletedPlanChangeSets()
				);
				const initialGenerationContext: EnhancedGenerationContext = {
					...context,
					fileStructureAnalysis: fileStructureAnalysis,
					successfulChangeHistory: successfulChangeHistory,
					lastFailedCorrectionDiff: undefined, // No failed diff yet
				};

				const initialContent = await this._generateInitialContent(
					filePath,
					generatePrompt,
					initialGenerationContext,
					modelName,
					streamId,
					token,
					onCodeChunkCallback
				);

				const validation = await this._validateAndRefineContent(
					filePath,
					initialContent,
					initialGenerationContext, // Pass context with structured analysis
					modelName,
					streamId,
					token,
					onCodeChunkCallback
				);

				const result = {
					content: validation.finalContent,
					validation,
				};
				this.postMessageToWebview({
					type: "codeFileStreamEnd",
					value: { streamId: streamId, filePath: filePath, success: true },
				});
				return result;
			}
		} catch (error: any) {
			this.postMessageToWebview({
				type: "codeFileStreamEnd",
				value: {
					streamId: streamId,
					filePath: filePath,
					success: false,
					error: error instanceof Error ? error.message : String(error),
				},
			});
			throw error;
		}
	}

	/**
	 * Enhanced file modification with intelligent diff analysis and inline edit support
	 */
	public async modifyFileContent(
		filePath: string,
		modificationPrompt: string,
		currentContent: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<{ content: string; validation: CodeValidationResult }> {
		const languageId = this._getLanguageId(path.extname(filePath));
		const streamId = crypto.randomUUID();

		this.postMessageToWebview({
			type: "codeFileStreamStart",
			value: { streamId: streamId, filePath: filePath, languageId: languageId },
		});

		try {
			const result = await this._modifyFileContentFull(
				filePath,
				modificationPrompt,
				currentContent,
				context,
				modelName,
				streamId,
				token,
				onCodeChunkCallback
			);
			this.postMessageToWebview({
				type: "codeFileStreamEnd",
				value: { streamId: streamId, filePath: filePath, success: true },
			});
			return result;
		} catch (error: any) {
			this.postMessageToWebview({
				type: "codeFileStreamEnd",
				value: {
					streamId: streamId,
					filePath: filePath,
					success: false,
					error: error instanceof Error ? error.message : String(error),
				},
			});
			throw error;
		}
	}

	/**
	 * Generate initial content with enhanced context analysis
	 */
	private async _generateInitialContent(
		filePath: string,
		generatePrompt: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<string> {
		const fileExtension = path.extname(filePath);
		const languageId = this._getLanguageId(fileExtension);

		// Enhanced prompt with better context analysis
		const enhancedPrompt = this._createEnhancedGenerationPrompt(
			filePath,
			generatePrompt,
			context,
			languageId
		);

		try {
			const rawContent = await this.aiRequestService.generateWithRetry(
				[{ text: enhancedPrompt }], // Modified: Wrap prompt string in HistoryEntryPart array
				modelName,
				undefined,
				"enhanced file generation",
				undefined,
				{
					onChunk: async (chunk: string) => {
						this.postMessageToWebview({
							type: "codeFileStreamChunk",
							value: { streamId: streamId, filePath: filePath, chunk: chunk },
						});
						if (onCodeChunkCallback) {
							await onCodeChunkCallback(chunk);
						}
					},
				},
				token
			);

			return cleanCodeOutput(rawContent);
		} catch (error: any) {
			throw error;
		}
	}

	/**
	 * Create enhanced generation prompt with better context analysis
	 */
	private _createEnhancedGenerationPrompt(
		filePath: string,
		generatePrompt: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		languageId: string
	): string {
		const fileAnalysis = this._analyzeFilePath(filePath);
		const styleGuide = this._getStyleGuide(languageId);

		return `You are an expert software engineer specializing in ${languageId} development. Your task is to generate production-ready, accurate code.

**CRITICAL REQUIREMENTS:**
1. **Accuracy First**: Ensure all imports, types, and dependencies are *absolutely* correct and precisely specified. Verify module paths, type definitions, and API usage.
2. **Style Consistency**: Adhere *rigorously* to the project's existing coding patterns, conventions, and formatting. Maintain current indentation, naming, and structural choices.
3. **Error Prevention**: Generate code that will compile and run *without any errors or warnings*. Proactively anticipate and guard against common pitfalls beyond just the immediate task, such as null/undefined checks, input validations, edge cases, and off-by-one errors.
4. **Best Practices**: Employ modern language features, established design patterns, and industry best practices to ensure high-quality, efficient, and robust code that is production-ready, maintainable, and clean.
5. **Surgical Precision & Minimal Changes**: DO NOT introduce extraneous refactoring, reformatting, or cosmetic alterations. Generate only the necessary new code.
6. **Security**: Implement secure coding practices meticulously, identifying and addressing potential vulnerabilities relevant to the language and context.

${
	context.isOscillating
		? `--- DETECTED CORRECTION OSCILLATION ---
**WARNING**: It appears the AI is stuck in a repetitive correction cycle, unable to resolve or continually re-introducing the same set of issues across recent attempts. This often happens when the AI tries similar fixes repeatedly without understanding the underlying cause or when changes conflict with other parts of the code.
**CRITICAL DIRECTIVE**: You MUST adopt a completely different, fundamentally new approach to break this cycle. Do NOT repeat similar failed attempts or minor adjustments. Analyze the historical outcomes from 'Recent Correction Attempt Outcomes' for patterns and propose a genuinely new correction strategy that tackles the problem from a different angle. This might involve:
-   Re-evaluating fundamental assumptions about the code or problem.
-   Considering alternative architectural patterns.
-   Breaking down the problem into smaller, more manageable sub-problems.
-   Searching for external documentation or examples if a common pattern is being misapplied.
-   Introducing new helper functions or refactoring a larger section if the existing structure is hostile to the fix.
--- END DETECTED CORRECTION OSCILLATION ---
`
		: ""
}
${
	context.lastCorrectionAttemptOutcome?.aiFailureAnalysis
		? `--- AI Self-Correction Analysis (from previous failed attempt) ---
**CRITICAL**: Read and internalize this analysis. It details *why* your previous attempt failed. You MUST adjust your strategy based on these insights to avoid repeating past mistakes.
**Previous Failure Analysis**:
${context.lastCorrectionAttemptOutcome.aiFailureAnalysis}
--- End AI Self-Correction Analysis ---
`
		: ""
}

**File Analysis:**
- Path: ${filePath}
- Language: ${languageId}
- Framework: ${fileAnalysis.framework}
- Project Structure: ${fileAnalysis.projectStructure}
- Expected Patterns: ${fileAnalysis.expectedPatterns}

**Style Guide:**
${styleGuide}
**Strict Adherence**: Rigorously follow all guidelines within this style guide to ensure seamless integration and absolute code consistency. Any deviation is considered a critical error.

**Instructions:**
${generatePrompt}

**Project Context:**
${context.projectContext}

**Relevant Snippets:**
${context.relevantSnippets}

${
	context.activeSymbolInfo
		? `**Active Symbol Info:**
- **Contextual Accuracy**: Use this info for correct integration, signatures, types, and naming for code interacting with these symbols.
${JSON.stringify(context.activeSymbolInfo, null, 2)}`
		: ""
}

${
	context.fileStructureAnalysis
		? this._formatFileStructureAnalysis(context.fileStructureAnalysis) + "\n"
		: ""
}
${
	context.successfulChangeHistory
		? `
**Change History:**
Analyze past successful patterns and apply effective solution strategies.
${context.successfulChangeHistory}
`
		: ""
}

**CRITICAL NEGATIVE CONSTRAINT**: Your response MUST ONLY contain the code for the SINGLE target file. DO NOT include any file headers, separators, or meta-information (e.g., \`--- File: ... ---\`, \`--- Relevant File: ... ---\`, \`--- Path: ... ---\`, \`--- End File ---\`, or any form of file delimiters) in your output. Your response must **start directly with the pure code content** on the first line and **end directly with the pure code content** on the last line, with no conversational text, explanations, or extraneous elements whatsoever.

Your response MUST contain **ONLY** the modified file content. **ONLY ADD PURE CODE, NOTHING ELSE, ONLY CODE.** **ABSOLUTELY NO MARKDOWN CODE BLOCK FENCES (\`\`\`typescript), NO CONVERSATIONAL TEXT, NO EXPLANATIONS, NO APOLOGIES, NO COMMENTS, NO EXTRA ELEMENTS WHATSOEVER.**`;
	}

	/**
	 * Validate and refine generated content
	 */
	private async _validateAndRefineContent(
		filePath: string,
		content: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<CodeValidationResult> {
		const validation = await this._validateCode(filePath, content);

		if (validation.isValid) {
			return {
				isValid: true,
				finalContent: content,
				issues: [],
				suggestions: validation.suggestions,
			};
		}

		// Refine content if validation failed
		const refinedContent = await this._refineContent(
			filePath,
			content,
			validation.issues,
			context,
			modelName,
			streamId,
			token,
			onCodeChunkCallback
		);

		const finalValidation = await this._validateCode(filePath, refinedContent);

		return {
			isValid: finalValidation.isValid,
			finalContent: refinedContent,
			issues: finalValidation.issues,
			suggestions: finalValidation.suggestions,
		};
	}

	/**
	 * Validate code for common issues
	 */
	private async _validateCode(
		filePath: string,
		content: string
	): Promise<CodeValidationResult> {
		const issues: CodeIssue[] = [];
		const suggestions: string[] = [];
		let hasError = false;

		const fileUri = vscode.Uri.file(filePath);
		const diagnostics = DiagnosticService.getDiagnosticsForUri(fileUri);

		for (const diag of diagnostics) {
			const severityName = getSeverityName(diag.severity);
			let issueSeverity: CodeIssue["severity"];
			let issueType: CodeIssue["type"];

			// Map VS Code severity to CodeIssue severity
			if (severityName === "Error") {
				issueSeverity = "error";
				hasError = true;
			} else if (severityName === "Warning") {
				issueSeverity = "warning";
			} else {
				issueSeverity = "info";
			}

			// Map VS Code diagnostic to CodeIssue type (prioritize specific types, then broad categories)
			const messageLower = diag.message.toLowerCase();
			if (messageLower.includes("unused import")) {
				issueType = "unused_import";
			} else if (
				issueSeverity === "error" ||
				issueSeverity === "warning" ||
				messageLower.includes("syntax") ||
				messageLower.includes("compilation") ||
				messageLower.includes("lint")
			) {
				issueType = "syntax"; // General compilation/linting issues
			} else if (messageLower.includes("security")) {
				issueType = "security"; // Explicitly map security if mentioned
			} else if (messageLower.includes("best practice")) {
				issueType = "best_practice"; // Explicitly map best practice if mentioned
			} else {
				issueType = "other"; // General fallback
			}

			let issueCode: string | number | undefined;
			if (
				typeof diag.code === "object" &&
				diag.code !== null &&
				"value" in diag.code
			) {
				issueCode = (diag.code as { value: string | number }).value;
			} else if (
				typeof diag.code === "string" ||
				typeof diag.code === "number"
			) {
				issueCode = diag.code;
			}

			issues.push({
				type: issueType,
				message: diag.message,
				line: diag.range.start.line + 1, // VS Code diagnostics are 0-indexed, CodeIssue is 1-indexed
				severity: issueSeverity,
				code: issueCode, // MODIFIED: Use issueCode
			});
		}

		// Generate suggestions for improvement
		if (issues.length === 0) {
			suggestions.push(
				"Code appears to be well-structured and follows best practices"
			);
		} else {
			suggestions.push(
				"Consider addressing the identified issues for better code quality"
			);
		}

		return {
			isValid: !hasError, // isValid is false if any error diagnostic is found
			finalContent: content, // content is not modified by this method
			issues,
			suggestions,
		};
	}

	/**
	 * Refine content based on validation issues
	 */
	private async _refineContent(
		filePath: string,
		content: string,
		issues: CodeIssue[],
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<string> {
		const languageId = this._getLanguageId(path.extname(filePath));
		// MODIFIED: Replace issue formatting
		const groupedAndPrioritizedIssues = this._groupAndPrioritizeIssues(issues);
		const formattedIssues = this._formatGroupedIssuesForPrompt(
			groupedAndPrioritizedIssues,
			languageId,
			content
		);

		const refinementPrompt = `The generated code has the following **VS Code-reported compilation/linting issues** that need to be fixed:

**Issues to Address:**
${formattedIssues}

**Original Content:**
\`\`\`${languageId}
${content}
\`\`\`

**Refinement Instructions:**
- **PRIORITY: ZERO ERRORS/WARNINGS**: Your primary objective is to resolve ALL reported issues in this single refinement attempt. The resulting code MUST compile and run without any errors or warnings.
-   **Surgical Precision**: Apply *only* the most targeted and minimal changes necessary to resolve the *exact* reported issues. Do not introduce any unrelated refactoring, reformatting, or cosmetic alterations.
-   **Preserve Surrounding Code**: Leave all code lines and blocks untouched if they are not directly involved in resolving an identified diagnostic.
-   **Maintain Indentation/Formatting**: Strictly adhere to the existing indentation, spacing, and formatting conventions of the original code.
- **Comprehensive Issue Resolution:** Fix *every single identified issue* meticulously, ensuring perfectly valid, error-free code.
- **Imports Correctness:** Verify and correct all imports. Ensure all necessary imports are present, and eliminate any unused or redundant ones.
- **Variable/Type Usage:** Reinforce correct variable declarations, scope, and accurate TypeScript types.
- **Functionality Preservation:** Ensure original or intended new functionality is perfectly maintained.
- **Compile/Runtime Errors:** Demand code that compiles and runs *without any errors or warnings*, proactively identifying and mitigating potential runtime issues, logical flaws, and edge cases (e.g., empty arrays, zero values), null/undefined checks, and off-by-one errors.
- **Code Style/Formatting:** Stricter adherence to existing project coding style and formatting conventions (indentation, spacing, line breaks, bracket placement, naming conventions), ensuring seamless integration.
- **Efficiency/Performance:** Instruct to review for code efficiency, optimizing loops, eliminating redundant computations, and choosing appropriate data structures/algorithms.
- **Modularity/Maintainability:** Ensure code is modular with clear separation of concerns, easy to read, understand, and maintain.
- **Production Readiness:** Demand the final code be production-ready, robust, and clean.

**Context:**
${context.projectContext}

**Snippets:**
${context.relevantSnippets}

${
	context.activeSymbolInfo
		? `**Active Symbol Info (for context/impact):**
- **Contextual Accuracy**: Use this info for correct integration, signatures, types, and naming for code interacting with these symbols.
${JSON.stringify(context.activeSymbolInfo, null, 2)}`
		: ""
}

${
	context.fileStructureAnalysis
		? this._formatFileStructureAnalysis(context.fileStructureAnalysis) + "\n"
		: ""
}

${
	context.successfulChangeHistory
		? `
**Change History:**
Analyze past successful patterns and apply effective solution strategies.
${context.successfulChangeHistory}
`
		: ""
}
${
	context.isOscillating
		? `--- DETECTED CORRECTION OSCILLATION ---
**WARNING**: It appears the AI is stuck in a repetitive correction cycle, unable to resolve or continually re-introducing the same set of issues across recent attempts. This often happens when the AI tries similar fixes repeatedly without understanding the underlying cause or when changes conflict with other parts of the code.
**CRITICAL DIRECTIVE**: You MUST adopt a completely different, fundamentally new approach to break this cycle. Do NOT repeat similar failed attempts or minor adjustments. Analyze the historical outcomes from 'Recent Correction Attempt Outcomes' for patterns and propose a genuinely new correction strategy that tackles the problem from a different angle. This might involve:
-   Re-evaluating fundamental assumptions about the code or problem.
-   Considering alternative architectural patterns.
-   Breaking down the problem into smaller, more manageable sub-problems.
-   Searching for external documentation or examples if a common pattern is being misapplied.
-   Introducing new helper functions or refactoring a larger section if the existing structure is hostile to the fix.
--- END DETECTED CORRECTION OSCILLATION ---
`
		: ""
}
${
	context.lastCorrectionAttemptOutcome?.aiFailureAnalysis
		? `--- AI Self-Correction Analysis (from previous failed attempt) ---
**CRITICAL**: Read and internalize this analysis. It details *why* your previous attempt failed. You MUST adjust your strategy based on these insights to avoid repeating past mistakes.
**Previous Failure Analysis**:
${context.lastCorrectionAttemptOutcome.aiFailureAnalysis}
--- End AI Self-Correction Analysis ---
`
		: ""
}

**CRITICAL NEGATIVE CONSTRAINT**: Your response MUST ONLY contain the code for the SINGLE target file. DO NOT include any file headers, separators, or meta-information (e.g., \`--- File: ... ---\`, \`--- Relevant File: ... ---\`, \`--- Path: ... ---\`, \`--- End File ---\`, or any form of file delimiters) in your output. Your response must **start directly with the pure code content** on the first line and **end directly with the pure code content** on the last line, with no conversational text, explanations, or extraneous elements whatsoever.

Your response MUST contain **ONLY** the modified file content. **ONLY ADD PURE CODE, NOTHING ELSE, ONLY CODE.** **ABSOLUTELY NO MARKDOWN CODE BLOCK FENCES (\`\`\`typescript), NO CONVERSATIONAL TEXT, NO EXPLANATIONS, NO APOLOGIES, NO COMMENTS, NO EXTRA ELEMENTS WHATSOEVER.**`;

		const rawContent = await this.aiRequestService.generateWithRetry(
			[{ text: refinementPrompt }], // Modified: Wrap prompt string in HistoryEntryPart array
			modelName,
			undefined,
			"code refinement",
			undefined,
			{
				onChunk: async (chunk: string) => {
					const currentStreamId = streamId;
					this.postMessageToWebview({
						type: "codeFileStreamChunk",
						value: {
							streamId: currentStreamId,
							filePath: filePath,
							chunk: chunk,
						},
					});
					if (onCodeChunkCallback) {
						await onCodeChunkCallback(chunk);
					}
				},
			},
			token
		);
		return cleanCodeOutput(rawContent);
	}

	/**
	 * Analyze file path for framework and structure information
	 */
	private _analyzeFilePath(filePath: string): FileAnalysis {
		const segments = filePath.split("/");
		const fileName = path.basename(filePath);
		const extension = path.extname(filePath);

		let framework = "unknown";
		let projectStructure = "unknown";
		let expectedPatterns = "standard";

		// Detect framework based on path structure
		if (segments.includes("pages") || segments.includes("app")) {
			framework = "Next.js";
			projectStructure = "pages/app router";
		} else if (segments.includes("src") && segments.includes("components")) {
			framework = "React";
			projectStructure = "src-based";
		} else if (segments.includes("src") && segments.includes("services")) {
			framework = "Node.js/Express";
			projectStructure = "service-oriented";
		}

		// Detect patterns based on file location
		if (segments.includes("components")) {
			expectedPatterns = "React component patterns";
		} else if (segments.includes("utils") || segments.includes("helpers")) {
			expectedPatterns = "utility function patterns";
		} else if (segments.includes("services")) {
			expectedPatterns = "service layer patterns";
		}

		return {
			framework,
			projectStructure,
			expectedPatterns,
			fileName,
			extension,
		};
	}

	/**
	 * Get language-specific style guide
	 */
	private _getStyleGuide(languageId: string): string {
		const guides: Record<string, string> = {
			typescript: `
- Use TypeScript strict mode
- Prefer interfaces over types for object shapes
- Use async/await over Promises
- Use const assertions where appropriate
- Prefer arrow functions for callbacks
- Use optional chaining and nullish coalescing
- Export named exports over default exports
- Use proper type annotations`,
			javascript: `
- Use ES6+ features (const, let, arrow functions)
- Prefer async/await over Promises
- Use optional chaining and nullish coalescing
- Use template literals over string concatenation
- Prefer arrow functions for callbacks
- Use proper JSDoc comments for documentation`,
			python: `
- Follow PEP 8 style guide
- Use type hints where appropriate
- Use f-strings over .format()
- Use list/dict comprehensions
- Prefer pathlib over os.path
- Use proper docstrings`,
			java: `
- Follow Java naming conventions
- Use proper access modifiers
- Implement equals() and hashCode() together
- Use try-with-resources for resource management
- Prefer Optional over null
- Use proper JavaDoc comments`,
		};

		return (
			guides[languageId] ||
			"Follow standard coding conventions for the language"
		);
	}

	/**
	 * Get language ID from file extension
	 */
	private _getLanguageId(extension: string): string {
		const languageMap: Record<string, string> = {
			".ts": "typescript",
			".tsx": "typescript",
			".js": "javascript",
			".jsx": "javascript",
			".py": "python",
			".java": "java",
			".cs": "csharp",
			".cpp": "cpp",
			".c": "c",
			".go": "go",
			".rs": "rust",
			".php": "php",
			".rb": "ruby",
			".swift": "swift",
			".kt": "kotlin",
		};

		return languageMap[extension] || "text";
	}

	/**
	 * Analyze file structure for modification context
	 */
	private async _analyzeFileStructure(
		filePath: string,
		content: string
	): Promise<FileStructureAnalysis> {
		const lines = content.split("\n");
		const structure: FileStructureAnalysis = {
			imports: [],
			exports: [],
			functions: [],
			classes: [],
			variables: [],
			comments: [],
		};

		for (let i = 0; i < lines.length; i++) {
			const line = lines[i].trim();

			if (line.startsWith("import ")) {
				structure.imports.push({ line: i + 1, content: line });
			} else if (line.startsWith("export ")) {
				structure.exports.push({ line: i + 1, content: line });
			} else if (line.includes("function ") || line.includes("=>")) {
				structure.functions.push({ line: i + 1, content: line });
			} else if (line.includes("class ")) {
				structure.classes.push({ line: i + 1, content: line });
			} else if (
				line.includes("const ") ||
				line.includes("let ") ||
				line.includes("var ")
			) {
				structure.variables.push({ line: i + 1, content: line });
			} else if (line.startsWith("//") || line.startsWith("/*")) {
				structure.comments.push({ line: i + 1, content: line });
			}
		}

		return structure;
	}

	/**
	 * Create Helper for Formatting `FileStructureAnalysis`
	 */
	private _formatFileStructureAnalysis(
		analysis?: FileStructureAnalysis
	): string {
		if (!analysis) {
			return "";
		}

		let formatted = "**File Structure Analysis:**\n";
		if (analysis.imports.length > 0) {
			formatted += `- Imports: ${analysis.imports.length} lines\n`;
		}
		if (analysis.exports.length > 0) {
			formatted += `- Exports: ${analysis.exports.length} lines\n`;
		}
		if (analysis.functions.length > 0) {
			formatted += `- Functions: ${analysis.functions.length} functions\n`;
		}
		if (analysis.classes.length > 0) {
			formatted += `- Classes: ${analysis.classes.length} classes\n`;
		}
		if (analysis.variables.length > 0) {
			formatted += `- Variables: ${analysis.variables.length} variables\n`;
		}
		if (analysis.comments.length > 0) {
			formatted += `- Comments: ${analysis.comments.length} lines\n`;
		}
		formatted +=
			"Analyze this structure to understand the file's organization and apply changes consistently.";
		return formatted;
	}

	/**
	 * Formats successful change sets into a concise string for AI prompts.
	 * Limits output to the last 3 change sets and 3 changes per set.
	 * @param changeSets An array of RevertibleChangeSet.
	 * @returns A formatted string summary of recent changes.
	 */
	private _formatSuccessfulChangesForPrompt(
		changeSets: RevertibleChangeSet[]
	): string {
		if (!changeSets || changeSets.length === 0) {
			return "";
		}

		const recentChangeSets = changeSets.slice(-3); // Get last 3 change sets
		let formattedHistory =
			"--- Recent Successful Project Changes (Context for AI) ---\n";

		for (const changeSet of recentChangeSets) {
			const date = new Date(changeSet.timestamp).toLocaleString();
			formattedHistory += `\n**Plan Executed on ${date} (ID: ${changeSet.id.substring(
				0,
				8
			)})**\n`;
			if (changeSet.planSummary) {
				// Changed from changeSet.summary
				formattedHistory += `Summary: ${changeSet.planSummary}\n`; // Changed from changeSet.summary
			}
			formattedHistory += `Changes:\n`;
			const limitedChanges = changeSet.changes.slice(0, 3); // Limit to last 3 changes per set
			for (const change of limitedChanges) {
				formattedHistory += `- **${change.changeType.toUpperCase()}**: \`${
					change.filePath
				}\` - ${change.summary.split("\n")[0]}\n`;
			}
			if (changeSet.changes.length > 3) {
				formattedHistory += `  ...and ${
					changeSet.changes.length - 3
				} more changes.\n`;
			}
		}
		formattedHistory += "\n--- End Recent Successful Project Changes ---\n";
		return formattedHistory;
	}

	/**
	 * Groups and prioritizes code issues for prompt generation.
	 * Issues are grouped by a combination of type, severity, and specific code (if applicable).
	 * Priorities are based on predefined orders (`issueTypeOrder`, `severityOrder`).
	 * Special handling for 'cannot find name' errors by grouping them by the missing identifier.
	 * @param issues An array of CodeIssue objects.
	 * @returns A Map where keys are formatted group headers and values are arrays of CodeIssue.
	 */
	private _groupAndPrioritizeIssues(
		issues: CodeIssue[]
	): Map<string, CodeIssue[]> {
		const groupedIssues = new Map<string, CodeIssue[]>();

		// Sort issues initially based on predefined order and then line number
		issues.sort((a, b) => {
			const typeOrderA = this.issueTypeOrder.indexOf(a.type);
			const typeOrderB = this.issueTypeOrder.indexOf(b.type);
			if (typeOrderA !== typeOrderB) {
				return typeOrderA - typeOrderB;
			}

			const severityOrderA = this.severityOrder.indexOf(a.severity);
			const severityOrderB = this.severityOrder.indexOf(b.severity);
			if (severityOrderA !== severityOrderB) {
				return severityOrderA - severityOrderB;
			}

			return a.line - b.line;
		});

		for (const issue of issues) {
			let groupKey = "";
			// Special grouping for 'cannot find name' errors
			if (
				issue.message.includes("Cannot find name") &&
				issue.type === "syntax" &&
				issue.severity === "error"
			) {
				const match = issue.message.match(/Cannot find name '([^']*)'/);
				const missingName = match ? match[1] : "unknown_identifier"; // Use "unknown_identifier" for clarity
				groupKey = `TYPE: ${issue.type.toUpperCase()} / SEVERITY: ${issue.severity.toUpperCase()} / ISSUE: Missing Identifier '${missingName}'`;
			} else {
				groupKey = `TYPE: ${issue.type.toUpperCase()} / SEVERITY: ${issue.severity.toUpperCase()}${
					issue.code ? ` / CODE: ${issue.code}` : ""
				}`;
			}

			if (!groupedIssues.has(groupKey)) {
				groupedIssues.set(groupKey, []);
			}
			groupedIssues.get(groupKey)!.push(issue);
		}

		return groupedIssues;
	}

	/**
	 * Formats grouped and prioritized issues into a Markdown string for AI prompts.
	 * @param groupedIssues A Map of grouped CodeIssue objects.
	 * @param languageId The language ID of the file (e.g., 'typescript', 'javascript').
	 * @param content The full content of the file to extract code snippets.
	 * @returns A formatted Markdown string representing the issues.
	 */
	private _formatGroupedIssuesForPrompt(
		groupedIssues: Map<string, CodeIssue[]>,
		languageId: string,
		content: string
	): string {
		let formattedString = "";

		// Sort group keys based on issue type and severity order
		const sortedGroupKeys = Array.from(groupedIssues.keys()).sort(
			(keyA, keyB) => {
				const issueTypeA =
					this.issueTypeOrder.find((type) =>
						keyA.includes(`TYPE: ${type.toUpperCase()}`)
					) || "other";
				const issueTypeB =
					this.issueTypeOrder.find((type) =>
						keyB.includes(`TYPE: ${type.toUpperCase()}`)
					) || "other";
				const typeOrderResult =
					this.issueTypeOrder.indexOf(issueTypeA as CodeIssue["type"]) -
					this.issueTypeOrder.indexOf(issueTypeB as CodeIssue["type"]);
				if (typeOrderResult !== 0) {
					return typeOrderResult;
				}

				const severityA =
					this.severityOrder.find((severity) =>
						keyA.includes(`SEVERITY: ${severity.toUpperCase()}`)
					) || "info";
				const severityB =
					this.severityOrder.find((severity) =>
						keyB.includes(`SEVERITY: ${severity.toUpperCase()}`)
					) || "info";
				return (
					this.severityOrder.indexOf(severityA as CodeIssue["severity"]) -
					this.severityOrder.indexOf(severityB as CodeIssue["severity"])
				);
			}
		);

		for (const groupKey of sortedGroupKeys) {
			const issuesInGroup = groupedIssues.get(groupKey)!;
			formattedString += `--- Issue Group: ${groupKey} ---\n`;

			// Add suggested strategy for the group
			let suggestedStrategy =
				"Review the provided code snippet and diagnostic message. Apply the most targeted fix to resolve this specific issue while adhering to all critical requirements.";
			if (groupKey.includes("ISSUE: Missing Identifier")) {
				suggestedStrategy =
					"Suggested Strategy: This group contains 'Cannot find name' errors, indicating a missing identifier. This almost always means a missing import statement, a typo in a variable/function/type name, or an undeclared variable/constant. Your specific action should be: 1. **Check Imports**: Verify if the missing identifier is an external dependency or a local module export; add the necessary import statement if it's missing. 2. **Check Typos**: Meticulously review the spelling of the identifier in both its usage and declaration. 3. **Check Scope/Declaration**: Ensure the identifier is declared and accessible within the current scope. If it's an undeclared variable, declare it with the correct type. Pay close attention to case sensitivity.";
			} else if (groupKey.includes("TYPE: UNUSED_IMPORT")) {
				suggestedStrategy =
					"Suggested Strategy: This group contains unused import warnings. This indicates an an import statement that is no longer being used by any code within the file. Your specific action should be: 1. **Remove Statement**: Delete the entire unused import statement. 2. **Verify No Reliance**: Before removal, quickly scan the file to ensure no other code unexpectedly relies on this import (e.g., dynamic usage not caught by static analysis).";
			} else if (groupKey.includes("TYPE: SECURITY")) {
				suggestedStrategy =
					"Suggested Strategy: This group contains security issues or vulnerabilities. Your specific action should be: 1. **Implement Secure Practices**: Apply standard secure coding practices relevant to the language and context (e.g., input validation, output encoding, proper authentication/authorization, secure data handling). 2. **Mitigate Vulnerability**: Directly address the vulnerability described in the message (e.g., prevent XSS, SQL injection, path traversal).";
			} else if (groupKey.includes("TYPE: BEST_PRACTICE")) {
				suggestedStrategy =
					"Suggested Strategy: This group contains best practice issues. These are typically suggestions for improving code quality, readability, maintainability, or performance, rather than critical errors. Your specific action should be: 1. **Refine Code**: Refactor small sections to align with established coding patterns, improve naming conventions, or use more idiomatic language features. 2. **Enhance Readability/Maintainability**: Focus on clarity, simplicity, and consistency without introducing new bugs.";
			} else if (
				groupKey.includes("TYPE: SYNTAX") &&
				groupKey.includes("ERROR")
			) {
				suggestedStrategy =
					"Suggested Strategy: This group contains critical syntax errors that prevent the code from compiling or parsing correctly. Your specific action should be: 1. **Correct Exact Mistake**: Focus solely on fixing the precise syntax mistake indicated by the diagnostic message (e.g., missing semicolon, incorrect keyword usage, mismatched parentheses/braces, incorrect function signature). 2. **Minimal Changes**: Ensure changes are localized and do not affect surrounding correct code.";
			} else if (groupKey.includes("TYPE: OTHER")) {
				suggestedStrategy =
					"Suggested Strategy: This group contains general or uncategorized issues. While not falling into specific categories, they still require attention. Your specific action should be: 1. **Analyze Message**: Carefully read the diagnostic message and examine the problematic code snippet. 2. **Precise Fix**: Apply a targeted and precise fix that directly resolves the issue without introducing unnecessary changes or side effects.";
			}
			formattedString += `Suggested Strategy: ${suggestedStrategy}\n`;

			for (const issue of issuesInGroup) {
				formattedString += `--- Individual Issue Details ---\n`;
				formattedString += `Severity: ${issue.severity.toUpperCase()}\n`;
				formattedString += `Type: ${issue.type}\n`;
				formattedString += `Line: ${issue.line}\n`;
				formattedString += `Message: ${issue.message}\n`;
				if (issue.code) {
					formattedString += `Issue Code: ${issue.code}\n`;
				}
				formattedString += `Problematic Code Snippet:\n`;
				formattedString += `\`\`\`${languageId}\n`;
				formattedString += `${this._getCodeSnippet(content, issue.line)}\n`;
				formattedString += `\`\`\`\n`;
				formattedString += `--- End Individual Issue Details ---\n\n`;
			}
			formattedString += "\n"; // Add extra newline between groups
		}

		return formattedString;
	}

	/**
	 * Generate modification with enhanced context
	 */
	private async _generateModification(
		filePath: string,
		modificationPrompt: string,
		currentContent: string,
		context: EnhancedGenerationContext, // MODIFIED: fileAnalysis now part of context
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<string> {
		const enhancedPrompt = this._createEnhancedModificationPrompt(
			filePath,
			modificationPrompt,
			currentContent,
			context // MODIFIED: Pass context directly
		);

		try {
			const rawContent = await this.aiRequestService.generateWithRetry(
				[{ text: enhancedPrompt }], // Modified: Wrap prompt string in HistoryEntryPart array
				modelName,
				undefined,
				"enhanced file modification",
				undefined,
				{
					onChunk: async (chunk: string) => {
						this.postMessageToWebview({
							type: "codeFileStreamChunk",
							value: { streamId: streamId, filePath: filePath, chunk: chunk },
						});
						if (onCodeChunkCallback) {
							await onCodeChunkCallback(chunk);
						}
					},
				},
				token
			);
			return cleanCodeOutput(rawContent);
		} catch (error: any) {
			throw error;
		}
	}

	/**
	 * Create enhanced modification prompt
	 */
	private _createEnhancedModificationPrompt(
		filePath: string,
		modificationPrompt: string,
		currentContent: string,
		context: EnhancedGenerationContext // MODIFIED: fileAnalysis now part of context
	): string {
		const languageId = this._getLanguageId(path.extname(filePath));
		// MODIFIED: Get fileAnalysis from context
		const fileAnalysis = context.fileStructureAnalysis;

		return `You are an expert software engineer. Your task is to modify the existing file according to the provided instructions.

**CRITICAL REQUIREMENTS:**
1. **Preserve Existing Structure**: Maintain the current file organization, structural patterns, and architectural design without unrelated refactoring. This is paramount for seamless integration.
2. **Surgical Precision & Minimal Changes**: Make *only* the exact, most targeted and minimal changes required by the 'Modification Instructions'. Do not introduce extraneous refactoring, reformatting, or stylistic changes (e.g., whitespace-only changes, reordering unrelated code blocks) unless explicitly requested and essential for the modification.
3. **No Cosmetic-Only Changes**: Your output must represent a *functional or structural change*, strictly avoiding changes that are solely whitespace, comments, or minor formatting, unless explicitly requested.
4. **Maintain Imports**: Maintain all *necessary* existing imports and add *only* strictly required new ones. Ensure import order is preserved unless a new logical grouping is absolutely essential for the requested modification.
5. **Consistent Style**: Strictly follow the existing code style, formatting, and conventions of the current file.
6. **Error Prevention**: Ensure the modified code compiles and runs *without any errors or warnings* and proactively address potential runtime issues, logical flaws, and edge cases (e.g., null/undefined checks, off-by-one errors, input validations).
7. **Production Readiness**: Stress robustness, maintainability, and adherence to best practices for all modifications.
**PRIORITY: ZERO ERRORS/WARNINGS**: Your generated modification MUST compile and run without any VS Code reported errors or warnings in this single attempt.

Path: ${filePath}
Language: ${languageId}

${this._formatFileStructureAnalysis(fileAnalysis)}

**Instructions:**
${modificationPrompt}

**Current Content:**
\`\`\`${languageId}
${currentContent}
\`\`\`

**Context:**
${context.projectContext}

**Snippets:**
${context.relevantSnippets}

${
	context.activeSymbolInfo
		? `**Active Symbol Info:**
- **Contextual Accuracy**: Use this info for correct integration, signatures, types, and naming for code interacting with these symbols.
${JSON.stringify(context.activeSymbolInfo, null, 2)}`
		: ""
}

${
	context.successfulChangeHistory
		? `
**Change History:**
Analyze past effective patterns and solution strategies.
${context.successfulChangeHistory}
`
		: ""
}
${
	context.isOscillating
		? `--- DETECTED CORRECTION OSCILLATION ---
**WARNING**: It appears the AI is stuck in a repetitive correction cycle, unable to resolve or continually re-introducing the same set of issues across recent attempts. This often happens when the AI tries similar fixes repeatedly without understanding the underlying cause or when changes conflict with other parts of the code.
**CRITICAL DIRECTIVE**: You MUST adopt a completely different, fundamentally new approach to break this cycle. Do NOT repeat similar failed attempts or minor adjustments. Analyze the historical outcomes from 'Recent Correction Attempt Outcomes' for patterns and propose a genuinely new correction strategy that tackles the problem from a different angle. This might involve:
-   Re-evaluating fundamental assumptions about the code or problem.
-   Considering alternative architectural patterns.
-   Breaking down the problem into smaller, more manageable sub-problems.
-   Searching for external documentation or examples if a common pattern is being misapplied.
-   Introducing new helper functions or refactoring a larger section if the existing structure is hostile to the fix.
--- END DETECTED CORRECTION OSCILLATION ---
`
		: ""
}
${
	context.lastCorrectionAttemptOutcome?.aiFailureAnalysis
		? `--- AI Self-Correction Analysis (from previous failed attempt) ---
**CRITICAL**: Read and internalize this analysis. It details *why* your previous attempt failed. You MUST adjust your strategy based on these insights to avoid repeating past mistakes.
**Previous Failure Analysis**:
${context.lastCorrectionAttemptOutcome.aiFailureAnalysis}
--- End AI Self-Correction Analysis ---
`
		: ""
}

**CRITICAL NEGATIVE CONSTRAINT**: Your response MUST ONLY contain the code for the SINGLE target file. DO NOT include any file headers, separators, or meta-information (e.g., \`--- File: ... ---\`, \`--- Relevant File: ... ---\`, \`--- Path: ... ---\`, \`--- End File ---\`, or any form of file delimiters) in your output. Your response must **start directly with the pure code content** on the first line and **end directly with the pure code content** on the last line, with no conversational text, explanations, or extraneous elements whatsoever.

Your response MUST contain **ONLY** the modified file content. **ONLY ADD PURE CODE, NOTHING ELSE, ONLY CODE.** **ABSOLUTELY NO MARKDOWN CODE BLOCK FENCES (\`\`\`typescript), NO CONVERSATIONAL TEXT, NO EXPLANATIONS, NO APOLOGIES, NO COMMENTS, NO EXTRA ELEMENTS WHATSOEVER.**`;
	}

	/**
	 * Validate and refine modification
	 */
	private async _validateAndRefineModification(
		filePath: string,
		originalContent: string,
		modifiedContent: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<CodeValidationResult> {
		// Check if the modification is reasonable
		const diffAnalysis = this._analyzeDiff(originalContent, modifiedContent);

		if (diffAnalysis.isReasonable) {
			const validation = await this._validateCode(filePath, modifiedContent);
			return {
				isValid: validation.isValid,
				finalContent: modifiedContent,
				issues: validation.issues,
				suggestions: validation.suggestions,
			};
		}

		// If the modification seems unreasonable, try to refine it
		const refinedContent = await this._refineModification(
			filePath,
			originalContent,
			modifiedContent,
			diffAnalysis.issues,
			context,
			modelName,
			streamId,
			token,
			onCodeChunkCallback
		);

		const finalValidation = await this._validateCode(filePath, refinedContent);

		return {
			isValid: finalValidation.isValid,
			finalContent: refinedContent,
			issues: finalValidation.issues,
			suggestions: finalValidation.suggestions,
		};
	}

	/**
	 * Analyze the diff between original and modified content
	 */
	private _analyzeDiff(original: string, modified: string): DiffAnalysis {
		const originalLines = original.split("\n");
		const modifiedLines = modified.split("\n");

		const issues: string[] = [];
		let isReasonable = true;

		// Check if the modification is too drastic
		const originalLength = originalLines.length;
		const modifiedLength = modifiedLines.length;
		const changeRatio =
			originalLength === 0
				? modifiedLength > 0
					? 1
					: 0
				: Math.abs(modifiedLength - originalLength) / originalLength;

		if (changeRatio > 0.8) {
			issues.push(
				"Modification seems too drastic - consider a more targeted approach"
			);
			isReasonable = false;
		}

		// Check if essential structure is preserved
		const originalImports = originalLines.filter((line) =>
			line.trim().startsWith("import")
		);
		const modifiedImports = modifiedLines.filter((line) =>
			line.trim().startsWith("import")
		);

		if (originalImports.length > 0 && modifiedImports.length === 0) {
			issues.push("All imports were removed - this may be incorrect");
			isReasonable = false;
		}

		return {
			isReasonable,
			issues,
			changeRatio,
		};
	}

	/**
	 * Refine modification based on diff analysis
	 */
	private async _refineModification(
		filePath: string,
		originalContent: string,
		modifiedContent: string,
		diffIssues: string[], // Renamed 'issues' to 'diffIssues' to avoid conflict with `issues` for `_validateCode`
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<string> {
		const languageId = this._getLanguageId(path.extname(filePath));
		let initialFeedback =
			"The modification seems to have issues that need to be addressed:";

		if (
			diffIssues.includes(
				"Modification seems too drastic - consider a more targeted approach"
			)
		) {
			initialFeedback +=
				"\n- **Drastic Change Detected**: The changes introduce a very high ratio of new/removed lines compared to the original content. This might indicate an unintended refactoring or deletion.";
		}
		if (
			diffIssues.includes("All imports were removed - this may be incorrect")
		) {
			initialFeedback +=
				"\n- **Import Integrity Compromised**: All imports appear to have been removed, which is highly likely to cause compilation errors.";
		}
		if (
			diffIssues.length === 0 &&
			(this._analyzeDiff(originalContent, modifiedContent).changeRatio > 0.8 ||
				this._analyzeDiff(originalContent, modifiedContent).issues.length > 0)
		) {
			// Fallback if diffIssues array is empty but diff analysis still flags issues (e.g., from initial call to _validateAndRefineModification)
			if (
				this._analyzeDiff(originalContent, modifiedContent).changeRatio > 0.8
			) {
				initialFeedback +=
					"\n- **Drastic Change Detected**: The changes introduce a very high ratio of new/removed lines compared to the original content. This might indicate an unintended refactoring or deletion.";
			}
			if (
				this._analyzeDiff(originalContent, modifiedContent).issues.includes(
					"All imports were removed - this may be incorrect"
				)
			) {
				initialFeedback +=
					"\n- **Import Integrity Compromised**: All imports appear to have been removed, which is highly likely to cause compilation errors.";
			}
		}

		const refinementPrompt = `${initialFeedback}\n\n**Issues with the modification:**\n${diffIssues
			.map((issue) => `- ${issue}`)
			.join(
				"\n"
			)}\n\n**Original Content:**\n\`\`\`${languageId}\n${originalContent}\n\`\`\`\n\n**Current Modification:**\n\`\`\`${languageId}\n${modifiedContent}\n\`\`\`\n\n**Refinement Instructions:**
- **PRIORITY: ZERO ERRORS/WARNINGS**: Your primary objective is to resolve ALL reported issues in this single refinement attempt. The resulting code MUST compile and run without any errors or warnings.
- **Surgical Precision**: Apply *only* the most targeted and minimal changes necessary to resolve the *exact* reported issues. Do not introduce any unrelated refactoring, reformatting, or cosmetic alterations.
- **Preserve Surrounding Code**: Leave all code lines and blocks untouched if they are not directly involved in resolving an identified diagnostic.
- **Maintain Indentation/Formatting**: Strictly adhere to the existing indentation, spacing, and formatting conventions of the original code.
- **Revert Unintended Structural Changes**: If the modification drastically altered the file's inherent structure (e.g., deleted major components or refactored unrelated sections), revert those unintended changes.
- **Maintain Import Integrity**: Ensure all necessary imports are present and correct. Do not remove existing imports unless they are explicitly unused by the new, correct code. Add only strictly required new imports.
- **Targeted Changes**: For small functional changes, ensure the modification is highly localized and does not affect unrelated parts of the codebase.
- **Minimize Diff Size:** Strive to make the diff (changes between 'Original Content' and 'Current Modification') as small and focused as possible. Avoid unnecessary line additions or deletions.
- **Strict Style Adherence:** Strictly adhere to the original file's existing code style, formatting (indentation, spacing, line breaks, bracket placement), and naming conventions.
- **Functionality and Correctness:** Ensure the modified code maintains all original functionality and is fully functional and error-free after correction. Specifically address any **VS Code-reported compilation/linting issues**.

**Context:**
${context.projectContext}

**Snippets:**
${context.relevantSnippets}

${
	context.activeSymbolInfo
		? `**Active Symbol Info:**
- **Contextual Accuracy**: Use this info for correct integration, signatures, types, and naming for code interacting with these symbols.
${JSON.stringify(context.activeSymbolInfo, null, 2)}`
		: ""
}

${
	context.fileStructureAnalysis
		? this._formatFileStructureAnalysis(context.fileStructureAnalysis) + "\n"
		: ""
}

${
	context.successfulChangeHistory
		? `
**Change History:**
Analyze past successful patterns and apply effective solution strategies.
${context.successfulChangeHistory}
`
		: ""
}
${
	context.isOscillating
		? `--- DETECTED CORRECTION OSCILLATION ---
**WARNING**: It appears the AI is stuck in a repetitive correction cycle, unable to resolve or continually re-introducing the same set of issues across recent attempts. This often happens when the AI tries similar fixes repeatedly without understanding the underlying cause or when changes conflict with other parts of the code.
**CRITICAL DIRECTIVE**: You MUST adopt a completely different, fundamentally new approach to break this cycle. Do NOT repeat similar failed attempts or minor adjustments. Analyze the historical outcomes from 'Recent Correction Attempt Outcomes' for patterns and propose a genuinely new correction strategy that tackles the problem from a different angle. This might involve:
-   Re-evaluating fundamental assumptions about the code or problem.
-   Considering alternative architectural patterns.
-   Breaking down the problem into smaller, more manageable sub-problems.
-   Searching for external documentation or examples if a common pattern is being misapplied.
-   Introducing new helper functions or refactoring a larger section if the existing structure is hostile to the fix.
--- END DETECTED CORRECTION OSCILLATION ---
`
		: ""
}
${
	context.lastCorrectionAttemptOutcome?.aiFailureAnalysis
		? `--- AI Self-Correction Analysis (from previous failed attempt) ---
**CRITICAL**: Read and internalize this analysis. It details *why* your previous attempt failed. You MUST adjust your strategy based on these insights to avoid repeating past mistakes.
**Previous Failure Analysis**:
${context.lastCorrectionAttemptOutcome.aiFailureAnalysis}
--- End AI Self-Correction Analysis ---
`
		: ""
}

**CRITICAL NEGATIVE CONSTRAINT**: Your response MUST ONLY contain the code for the SINGLE target file. DO NOT include any file headers, separators, or meta-information (e.g., \`--- File: ... ---\`, \`--- Relevant File: ... ---\`, \`--- Path: ... ---\`, \`--- End File ---\`, or any form of file delimiters) in your output. Your response must **start directly with the pure code content** on the first line and **end directly with the pure code content** on the last line, with no conversational text, explanations, or extraneous elements whatsoever.

Your response MUST contain **ONLY** the modified file content. **ONLY ADD PURE CODE, NOTHING ELSE, ONLY CODE.** **ABSOLUTELY NO MARKDOWN CODE BLOCK FENCES (\`\`\`typescript), NO CONVERSATIONAL TEXT, NO EXPLANATIONS, NO APOLOGIES, NO COMMENTS, NO EXTRA ELEMENTS WHATSOEVER.**`;

		const rawContent = await this.aiRequestService.generateWithRetry(
			[{ text: refinementPrompt }], // Modified: Wrap prompt string in HistoryEntryPart array
			modelName,
			undefined,
			"refine modification",
			undefined,
			{
				onChunk: async (chunk: string) => {
					this.postMessageToWebview({
						type: "codeFileStreamChunk",
						value: { streamId: streamId, filePath: filePath, chunk: chunk },
					});
					if (onCodeChunkCallback) {
						await onCodeChunkCallback(chunk);
					}
				},
			},
			token
		);
		// Clean the output to ensure it contains only valid code
		// This is a safety net to ensure no extra text is included
		return cleanCodeOutput(rawContent);
	}

	/**
	 * Original full file modification method (fallback)
	 */
	private async _modifyFileContentFull(
		filePath: string,
		modificationPrompt: string,
		currentContent: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<{ content: string; validation: CodeValidationResult }> {
		// Step 1: Analyze current file structure and dependencies
		const fileAnalysis = await this._analyzeFileStructure(
			filePath,
			currentContent
		);

		// MODIFIED: Create a new context object that includes fileStructureAnalysis and successfulChangeHistory
		const contextWithAllAnalysis: EnhancedGenerationContext = {
			...context,
			fileStructureAnalysis: fileAnalysis,
			successfulChangeHistory: this._formatSuccessfulChangesForPrompt(
				this.changeLogger.getCompletedPlanChangeSets()
			), // NEW: Populate history
		};

		// Step 2: Generate modification with enhanced context
		const modifiedContent = await this._generateModification(
			filePath,
			modificationPrompt,
			currentContent,
			contextWithAllAnalysis, // MODIFIED: Pass the new context object
			modelName,
			streamId,
			token,
			onCodeChunkCallback
		);

		// Step 3: Validate and refine the modification
		const validation = await this._validateAndRefineModification(
			filePath,
			currentContent,
			modifiedContent,
			contextWithAllAnalysis, // MODIFIED: Pass the new context object
			modelName,
			streamId,
			token,
			onCodeChunkCallback
		);

		return {
			content: validation.finalContent,
			validation: {
				...validation,
			},
		};
	}

	/**
	 * Heuristically determines if the AI's raw text output is likely an error message
	 * instead of valid code/content.
	 * @param content The raw string content generated by the AI.
	 * @returns True if the content is likely an error message, false otherwise.
	 */
	private _isAIOutputLikelyErrorMessage(content: string): boolean {
		const lowerContent = content.toLowerCase().trim();

		// Common phrases indicating an AI error or inability to perform a task
		const errorPhrases = [
			"i am sorry",
			"i'm sorry",
			"i cannot fulfill this request",
			"i encountered an error",
			"i ran into an issue",
			"an error occurred",
			"i am unable to provide",
			"please try again",
			"i couldn't generate",
			"i'm having trouble",
			"error:",
			"failure:",
			"exception:",
			"i can't",
			"i am not able to",
			"as an ai model", // Often precedes an explanation for not being able to do something
			"i lack the ability to",
			"insufficient information",
			"invalid request",
			"not enough context",
		];

		// Common system/API error phrases that might be passed through
		const systemErrorPhrases = [
			"access denied",
			"file not found",
			"permission denied",
			"timeout",
			"rate limit",
			"quota exceeded",
			"server error",
			"api error",
		];

		// Combine all phrases
		const allErrorPhrases = [...errorPhrases, ...systemErrorPhrases];

		if (allErrorPhrases.some((phrase) => lowerContent.includes(phrase))) {
			return true;
		}

		// Heuristic for very short content that looks like an error
		// E.g., if it's less than 200 characters and contains keywords like "error", "fail", "issue"
		if (
			content.length < 200 &&
			(lowerContent.includes("error") ||
				lowerContent.includes("fail") ||
				lowerContent.includes("issue"))
		) {
			return true;
		}

		// Safety net: check for markdown code blocks that explicitly contain error-like text.
		// This is for cases where markdown stripping might fail or AI incorrectly wraps an error in a code block.
		const markdownErrorPattern =
			/(?:[a-zA-Z0-9]+)?\s*(error|fail|exception|apology|i am sorry)[\s\S]*?/i;
		if (markdownErrorPattern.test(content)) {
			return true;
		}

		return false;
	}

	/**
	 * Extracts a code snippet around a given line number.
	 * @param fullContent The full string content of the file.
	 * @param lineNumber The 1-indexed line number to center the snippet around.
	 * @param linesBefore The number of lines to include before the target line.
	 * @param linesAfter The number of lines to include after the target line.
	 * @returns A string containing the formatted code snippet.
	 */
	private _getCodeSnippet(
		fullContent: string,
		lineNumber: number,
		linesBefore: number = 2,
		linesAfter: number = 2
	): string {
		const lines = fullContent.split("\n");
		const zeroBasedLineNumber = lineNumber - 1; // Convert to 0-indexed

		const start = Math.max(0, zeroBasedLineNumber - linesBefore);
		const end = Math.min(lines.length - 1, zeroBasedLineNumber + linesAfter);

		const snippetLines: string[] = [];
		const maxLineNumLength = String(end + 1).length; // For padding

		for (let i = start; i <= end; i++) {
			const currentLineNum = i + 1; // Convert back to 1-indexed for display
			const paddedLineNum = String(currentLineNum).padStart(
				maxLineNumLength,
				" "
			);
			snippetLines.push(`${paddedLineNum}: ${lines[i]}`);
		}

		return snippetLines.join("\n");
	}

	/**
	 * Creates a unique string identifier for a CodeIssue.
	 * Used to compare issues and find newly introduced ones.
	 */
	private _getIssueIdentifier(issue: CodeIssue): string {
		return `${issue.message}|${issue.line}|${issue.type}|${issue.severity}|${
			issue.code ?? ""
		}`;
	}

	/**
	 * Identifies issues present in `newIssues` that were not in `originalIssues`.
	 */
	private _getIssuesIntroduced(
		originalIssues: CodeIssue[],
		newIssues: CodeIssue[]
	): CodeIssue[] {
		const originalIssueSet = new Set<string>(
			originalIssues.map(this._getIssueIdentifier)
		);
		return newIssues.filter(
			(issue) => !originalIssueSet.has(this._getIssueIdentifier(issue))
		);
	}

	/**
	 * Compares two lists of `CodeIssue` objects by checking issue message, type, and line number similarity.
	 * Returns `true` if they are substantially similar, indicating a potential cycle, and `false` otherwise.
	 */
	private _areIssuesSimilar(
		issues1: CodeIssue[],
		issues2: CodeIssue[]
	): boolean {
		if (issues1.length !== issues2.length) {
			return false;
		}

		if (issues1.length === 0 && issues2.length === 0) {
			return true; // Both empty, considered similar
		}

		const set1 = new Set<string>(issues1.map(this._getIssueIdentifier));
		const set2 = new Set<string>(issues2.map(this._getIssueIdentifier));

		if (set1.size !== set2.size) {
			return false;
		}

		for (const id of set1) {
			if (!set2.has(id)) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Detects if the AI is stuck in an oscillation (repeatedly failing to resolve similar issues).
	 * Checks `context.recentCorrectionAttemptOutcomes` for recurring similar issues.
	 * @param context The current enhanced generation context.
	 * @param currentIssuesCount The number of issues before the current failed correction attempt.
	 * @param correctedIssuesCount The number of issues after the current failed correction attempt.
	 * @returns `true` if an oscillation is detected, `false` otherwise.
	 */
	private async _detectOscillation(
		context: EnhancedGenerationContext,
		currentIssuesCount: number, // Not directly used in current simple logic, but can be for more complex heuristics
		correctedIssuesCount: number // Not directly used in current simple logic, but can be for more complex heuristics
	): Promise<boolean> {
		const recentOutcomes = context.recentCorrectionAttemptOutcomes;

		if (!recentOutcomes || recentOutcomes.length < 2) {
			return false; // Need at least two attempts to detect a pattern
		}

		// Check if the last two attempts both failed and left similar issues remaining
		const lastOutcome = recentOutcomes[recentOutcomes.length - 1];
		const secondLastOutcome = recentOutcomes[recentOutcomes.length - 2];

		if (
			!lastOutcome.success &&
			!secondLastOutcome.success &&
			this._areIssuesSimilar(
				lastOutcome.issuesRemaining,
				secondLastOutcome.issuesRemaining
			)
		) {
			// Basic oscillation detected: last two failed attempts left the same set of issues
			return true;
		}

		// More complex oscillation detection: e.g., if the issues count alternates but never resolves,
		// or if a specific issue consistently re-appears.
		// For now, the simple "same issues remaining after two failures" is sufficient.
		return false;
	}

	/**
	 * Implements the AI's self-analysis for a failed correction attempt.
	 * This method asks the AI to diagnose the root cause of the failure and suggest a new strategy.
	 */
	private async _generateAIFailureAnalysis(
		filePath: string,
		originalContent: string,
		attemptedContent: string,
		originalIssues: CodeIssue[],
		issuesAfterAttempt: CodeIssue[],
		languageId: string,
		iteration: number, // Pass iteration here for prompt context
		streamId: string,
		recentCorrectionAttemptOutcomes: CorrectionAttemptOutcome[] | undefined, // NEW parameter
		isOscillating: boolean | undefined, // NEW parameter
		token?: vscode.CancellationToken
	): Promise<string> {
		const { formattedDiff } = await generateFileChangeSummary(
			originalContent,
			attemptedContent,
			filePath
		);

		const formattedOriginalIssues = this._formatGroupedIssuesForPrompt(
			this._groupAndPrioritizeIssues(originalIssues),
			languageId,
			originalContent
		);
		const formattedIssuesAfterAttempt = this._formatGroupedIssuesForPrompt(
			this._groupAndPrioritizeIssues(issuesAfterAttempt),
			languageId,
			attemptedContent
		);

		let recentOutcomesSection = "";
		if (
			recentCorrectionAttemptOutcomes &&
			recentCorrectionAttemptOutcomes.length > 0
		) {
			recentOutcomesSection = `
**Recent Correction Attempt Outcomes (for oscillation analysis):**
${recentCorrectionAttemptOutcomes
	.map(
		(outcome, index) => `
  --- Outcome ${index + 1} (Iteration ${outcome.iteration}) ---
  Success: ${outcome.success}
  Original Issues: ${outcome.originalIssuesCount}
  Issues After Attempt: ${outcome.issuesAfterAttemptCount}
  Failure Type: ${outcome.failureType}
  Relevant Diff Summary: ${outcome.relevantDiff.substring(0, 100)}...
  Issues Remaining: ${outcome.issuesRemaining
		.map(
			(i) =>
				`- [${i.severity}] ${i.type} at line ${i.line}: ${i.message.substring(
					0,
					50
				)}...`
		)
		.join("\n    ")}
  Issues Introduced: ${outcome.issuesIntroduced
		.map(
			(i) =>
				`- [${i.severity}] ${i.type} at line ${i.line}: ${i.message.substring(
					0,
					50
				)}...`
		)
		.join("\n    ")}
  AI Failure Analysis (from that attempt): ${
		outcome.aiFailureAnalysis
			? outcome.aiFailureAnalysis.substring(0, 100) + "..."
			: "N/A"
	}
  --- End Outcome ${index + 1} ---
`
	)
	.join("\n")}
`;
		}

		const analysisPrompt = `You are an expert software engineer performing a root cause analysis on a failed code correction attempt.
Your primary goal is to diagnose WHY the previous attempt did not resolve issues or introduced new ones, and to provide actionable insights for the *next* correction.

**CRITICAL CONSTRAINT**: Your response MUST be ONLY plain text, summarizing the failure and strategy. ABSOLUTELY NO CODE BLOCKS (e.g., \`\`\`typescript), NO MARKDOWN FORMATTING (except basic bullet points if essential), NO CONVERSATIONAL FILLER (e.g., "I apologize", "Here is my analysis"), NO HEADERS, NO FOOTERS, NO GREETINGS, NO SIGNATURES. Start directly with the analysis.

**Analysis Context:**
- File path: ${filePath}
- Language: ${languageId}
- Current Iteration of Feedback Loop: ${iteration}

${
	isOscillating
		? `--- DETECTED CORRECTION OSCILLATION ---
**WARNING**: The system has detected that previous correction attempts are stuck in a repetitive cycle, repeatedly failing to resolve similar issues. This indicates a deeper problem or a fundamental misunderstanding of the fix required.
**CRITICAL DIRECTIVE**: Your analysis MUST identify the root cause of this oscillation and propose a **fundamentally different, breakthrough correction strategy** that avoids past mistakes and breaks the cycle. Do NOT suggest minor tweaks or repetitions of failed approaches.
--- END DETECTED CORRECTION OSCILLATION ---
`
		: ""
}

${recentOutcomesSection}

**Content BEFORE this Attempt:**
\`\`\`${languageId}
${originalContent}
\`\`\`

**Issues Identified BEFORE this Attempt (${originalIssues.length} issues):**
${formattedOriginalIssues}

**Content AFTER this Attempt:**
\`\`\`${languageId}
${attemptedContent}
\`\`\`

**Issues Identified AFTER this Attempt (${issuesAfterAttempt.length} issues):**
${formattedIssuesAfterAttempt}

**Relevant Diff (changes made in this attempt):**
\`\`\`diff
${formattedDiff}
\`\`\`

**Instructions for Your Analysis:**
1.  **Root Cause Diagnosis**: Based on the context provided (original code, attempted code, diff, and issue lists *before* and *after*, and especially 'Recent Correction Attempt Outcomes' if available), clearly state the precise root cause(s) of the failure. Focus on specific code changes (or lack thereof) that led to the issues persisting or new ones appearing. For an oscillation, explicitly diagnose *why* the cycle is occurring.
2.  **Actionable Strategy**: Propose a concrete, fundamentally different strategy for the *next* correction attempt. Explain *how* the AI should adjust its approach to successfully resolve the issues this time, explicitly addressing the identified root causes and aiming to break any detected oscillation patterns.
3.  **No Code**: Reiterate: Your output must be *only* the analysis text. Do not provide any code suggestions or snippets.
4. **Brevity**: Keep the analysis concise and to the point.`;

		try {
			const rawAnalysis = await this.aiRequestService.generateWithRetry(
				[{ text: analysisPrompt }],
				"gemini-pro", // Using a capable model for analysis
				undefined,
				"ai failure analysis",
				undefined,
				undefined,
				token
			);
			return cleanCodeOutput(rawAnalysis); // Ensure no markdown or extra text
		} catch (error) {
			console.error(
				"[EnhancedCodeGenerator] Error generating AI failure analysis:",
				error
			);
			return `Failed to generate AI failure analysis: ${
				error instanceof Error ? error.message : String(error)
			}.`;
		}
	}

	/**
	 * Generate content with real-time feedback loop
	 */
	private async _generateWithRealTimeFeedback(
		filePath: string,
		generatePrompt: string,
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		feedbackCallback?: (feedback: RealTimeFeedback) => void,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<{ content: string; validation: CodeValidationResult }> {
		let currentContent = "";
		let iteration = 0;
		let totalIssues = 0;
		let resolvedIssues = 0;

		// Initialize context properties that will be updated in the loop
		let currentContext: EnhancedGenerationContext = {
			...context,
			lastFailedCorrectionDiff: undefined,
			successfulChangeHistory: this._formatSuccessfulChangesForPrompt(
				this.changeLogger.getCompletedPlanChangeSets()
			),
			lastCorrectionAttemptOutcome: undefined, // NEW: Initialize as undefined
			recentCorrectionAttemptOutcomes: [], // NEW: Initialize as empty array
			isOscillating: false, // NEW: Initialize as false
		};

		this._sendFeedback(feedbackCallback, {
			stage: "initialization",
			message: "Starting code generation with real-time validation...",
			issues: [],
			suggestions: [
				"Analyzing project context",
				"Preparing generation strategy",
			],
			progress: 0,
		});

		try {
			this._sendFeedback(feedbackCallback, {
				stage: "generation",
				message: "Generating initial code structure...",
				issues: [],
				suggestions: ["Creating file structure", "Adding imports"],
				progress: 20,
			});

			// Analyze file structure *before* initial content generation, as it's needed for the prompt
			currentContext.fileStructureAnalysis = await this._analyzeFileStructure(
				filePath,
				"" // Initial content is empty, so analysis is based on surrounding context/empty file.
			);

			currentContent = await this._generateInitialContent(
				filePath,
				generatePrompt,
				currentContext, // Use updated context for initial generation
				modelName,
				streamId,
				token,
				onCodeChunkCallback
			);

			while (iteration < this.config.maxFeedbackIterations!) {
				if (token?.isCancellationRequested) {
					throw new Error("Operation cancelled");
				}

				iteration++;
				this._sendFeedback(feedbackCallback, {
					stage: "validation",
					message: `Validating code (iteration ${iteration}/${this.config.maxFeedbackIterations})...`,
					issues: [],
					suggestions: [
						"Checking syntax",
						"Validating imports",
						"Analyzing structure",
					],
					progress: 20 + iteration * 15,
				});

				const currentContentBeforeCorrectionAttempt = currentContent;

				const validation = await this._validateCode(filePath, currentContent);
				const currentIssues = validation.issues.length;

				// Always update file structure and successful change history for current context within the loop
				currentContext.fileStructureAnalysis = await this._analyzeFileStructure(
					filePath,
					currentContent
				);
				currentContext.successfulChangeHistory =
					this._formatSuccessfulChangesForPrompt(
						this.changeLogger.getCompletedPlanChangeSets()
					);

				if (currentIssues === 0) {
					this._sendFeedback(feedbackCallback, {
						stage: "completion",
						message: "Code generation completed successfully!",
						issues: [],
						suggestions: validation.suggestions,
						progress: 100,
					});

					currentContext.lastFailedCorrectionDiff = undefined; // Clear diff on success
					currentContext.lastCorrectionAttemptOutcome = undefined; // NEW: Clear outcome on success
					currentContext.recentCorrectionAttemptOutcomes = undefined; // NEW: Clear recent outcomes on success
					currentContext.isOscillating = undefined; // NEW: Clear oscillation status on success
					return {
						content: currentContent,
						validation: {
							...validation,
							finalContent: currentContent,
							iterations: iteration,
							totalIssues: totalIssues,
							resolvedIssues: resolvedIssues,
						},
					};
				}

				totalIssues += currentIssues;

				this._sendFeedback(feedbackCallback, {
					stage: "correction",
					message: `Found ${currentIssues} VS Code-reported compilation/linting issues, applying corrections...`,
					issues: validation.issues,
					suggestions: [
						"Fixing syntax errors",
						"Correcting imports",
						"Improving structure",
					],
					progress: 20 + iteration * 15,
				});

				const correctedContent = await this._applyRealTimeCorrections(
					filePath,
					currentContent,
					validation.issues,
					currentContext, // Pass updated context
					modelName,
					streamId,
					token,
					onCodeChunkCallback
				);

				const correctedValidation = await this._validateCode(
					filePath,
					correctedContent
				);
				const correctedIssues = correctedValidation.issues.length;

				if (correctedIssues < currentIssues) {
					resolvedIssues += currentIssues - correctedIssues;
					currentContent = correctedContent;
					currentContext.lastFailedCorrectionDiff = undefined; // Clear diff on improvement
					currentContext.lastCorrectionAttemptOutcome = undefined; // NEW: Clear outcome on improvement
					currentContext.recentCorrectionAttemptOutcomes = undefined; // NEW: Clear recent outcomes on improvement
					currentContext.isOscillating = undefined; // NEW: Clear oscillation status on improvement

					this._sendFeedback(feedbackCallback, {
						stage: "improvement",
						message: `Resolved ${
							currentIssues - correctedIssues
						} issues (${correctedIssues} remaining)...`,
						issues: correctedValidation.issues,
						suggestions: correctedValidation.suggestions,
						progress: 20 + iteration * 15,
					});
				} else if (correctedIssues >= currentIssues) {
					// No improvement or made things worse, capture diff and try alternative approach
					const { formattedDiff } = await generateFileChangeSummary(
						currentContentBeforeCorrectionAttempt,
						correctedContent,
						filePath
					);

					// Determine issues introduced by this specific attempt
					const issuesIntroduced = this._getIssuesIntroduced(
						validation.issues,
						correctedValidation.issues
					);

					// Determine failure type based on issue counts
					let failureType: CorrectionAttemptOutcome["failureType"];
					if (correctedIssues > currentIssues) {
						failureType = "new_errors_introduced";
					} else {
						failureType = "no_improvement";
					}

					// Create CorrectionAttemptOutcome for the current failed attempt
					const currentFailedOutcome: CorrectionAttemptOutcome = {
						success: false, // Since no improvement or worse
						iteration: iteration,
						originalIssuesCount: currentIssues,
						issuesAfterAttemptCount: correctedIssues,
						issuesRemaining: correctedValidation.issues,
						issuesIntroduced: issuesIntroduced,
						relevantDiff: formattedDiff,
						aiFailureAnalysis: "", // Will be filled below
						failureType: failureType,
					};

					// Initialize recentCorrectionAttemptOutcomes if it doesn't exist
					if (!currentContext.recentCorrectionAttemptOutcomes) {
						currentContext.recentCorrectionAttemptOutcomes = [];
					}
					// Add the current failed outcome to the history
					currentContext.recentCorrectionAttemptOutcomes.push(
						currentFailedOutcome
					);
					// Trim the history to the fixed size
					if (
						currentContext.recentCorrectionAttemptOutcomes.length >
						this.MAX_OSCILLATION_HISTORY_SIZE
					) {
						currentContext.recentCorrectionAttemptOutcomes.shift();
					}

					// Detect oscillation based on the updated history
					currentContext.isOscillating = await this._detectOscillation(
						currentContext,
						currentIssues,
						correctedIssues
					);

					// Generate AI failure analysis, passing current context details including oscillation status
					const aiFailureAnalysis = await this._generateAIFailureAnalysis(
						filePath,
						currentContentBeforeCorrectionAttempt,
						correctedContent,
						validation.issues,
						correctedValidation.issues,
						this._getLanguageId(path.extname(filePath)),
						iteration,
						streamId,
						currentContext.recentCorrectionAttemptOutcomes, // Pass the recent outcomes
						currentContext.isOscillating, // Pass the oscillation status
						token
					);

					// Update the currentFailedOutcome with the generated analysis
					currentFailedOutcome.aiFailureAnalysis = aiFailureAnalysis;

					// Assign the fully populated outcome to lastCorrectionAttemptOutcome
					currentContext.lastCorrectionAttemptOutcome = currentFailedOutcome;

					// Set lastFailedCorrectionDiff to undefined as new outcome object replaces its function
					currentContext.lastFailedCorrectionDiff = undefined;

					this._sendFeedback(feedbackCallback, {
						stage: "alternative",
						message:
							"Correction did not improve the situation, trying alternative approach...",
						issues: validation.issues,
						suggestions: ["Using different strategy", "Analyzing patterns"],
						progress: 20 + iteration * 15,
					});

					const alternativeContent = await this._applyAlternativeCorrections(
						filePath,
						currentContent, // Pass original content for alternative strategy if previous attempt was bad
						validation.issues,
						currentContext, // Pass updated context with failed diff, outcome, recent outcomes, and oscillation status
						modelName,
						streamId,
						token,
						onCodeChunkCallback
					);

					const alternativeValidation = await this._validateCode(
						filePath,
						alternativeContent
					);

					if (alternativeValidation.issues.length < currentIssues) {
						currentContent = alternativeContent;
						resolvedIssues +=
							currentIssues - alternativeValidation.issues.length;
						currentContext.lastFailedCorrectionDiff = undefined; // Clear diff on successful alternative
						currentContext.lastCorrectionAttemptOutcome = undefined; // NEW: Clear outcome on successful alternative
						currentContext.recentCorrectionAttemptOutcomes = undefined; // NEW: Clear recent outcomes on successful alternative
						currentContext.isOscillating = undefined; // NEW: Clear oscillation status on successful alternative
					} else {
						// Still no improvement with alternative approach, break loop
						this._sendFeedback(feedbackCallback, {
							stage: "revert",
							message:
								"Alternative correction failed or made issues worse. Stopping automatic corrections.",
							issues: validation.issues,
							suggestions: [
								"Manual review recommended",
								"Consider providing more context",
							],
							progress: 20 + iteration * 15,
						});
						break; // Break to avoid infinite loop
					}
				}
			}

			// Final validation after loop exits
			const finalValidation = await this._validateCode(
				filePath,
				currentContent
			);

			this._sendFeedback(feedbackCallback, {
				stage: "final",
				message: `Code generation completed with ${finalValidation.issues.length} remaining issues`,
				issues: finalValidation.issues,
				suggestions: finalValidation.suggestions,
				progress: 100,
			});

			return {
				content: currentContent,
				validation: {
					...finalValidation,
					finalContent: currentContent,
					iterations: iteration,
					totalIssues: totalIssues,
					resolvedIssues: resolvedIssues,
				},
			};
		} catch (error) {
			this._sendFeedback(feedbackCallback, {
				stage: "error",
				message: `Code generation failed: ${
					error instanceof Error ? error.message : String(error)
				}`,
				issues: [],
				suggestions: [
					"Check error details in output",
					"Try again with different approach",
				],
				progress: 100,
			});

			throw error;
		}
	}

	/**
	 * Apply real-time corrections based on validation issues
	 */
	private async _applyRealTimeCorrections(
		filePath: string,
		content: string,
		issues: CodeIssue[],
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<string> {
		const syntaxIssues = issues.filter((i) => i.type === "syntax");
		const importIssues = issues.filter((i) => i.type === "unused_import");
		const bestPracticeIssues = issues.filter((i) => i.type === "best_practice");
		const securityIssues = issues.filter((i) => i.type === "security");
		const otherIssues = issues.filter((i) => i.type === "other");

		let correctedContent = content;

		// Apply corrections in order of priority
		if (syntaxIssues.length > 0) {
			correctedContent = await this._correctSyntaxIssues(
				filePath,
				correctedContent,
				syntaxIssues,
				context,
				modelName,
				streamId,
				token,
				onCodeChunkCallback
			);
		}

		if (token?.isCancellationRequested) {
			throw new Error("Operation cancelled");
		}

		if (importIssues.length > 0) {
			correctedContent = await this._correctImportIssues(
				filePath,
				correctedContent,
				importIssues,
				context,
				modelName,
				streamId,
				token,
				onCodeChunkCallback
			);
		}

		if (token?.isCancellationRequested) {
			throw new Error("Operation cancelled");
		}

		// Combine best_practice and general 'other' issues, as they might stem from general diagnostics
		const combinedPracticeAndOtherIssues = [
			...bestPracticeIssues,
			...otherIssues,
		];
		if (combinedPracticeAndOtherIssues.length > 0) {
			correctedContent = await this._correctPracticeIssues(
				filePath,
				correctedContent,
				combinedPracticeAndOtherIssues, // Pass combined issues
				context,
				modelName,
				streamId,
				token,
				onCodeChunkCallback
			);
		}

		if (token?.isCancellationRequested) {
			throw new Error("Operation cancelled");
		}

		// Explicitly call _correctSecurityIssues, even if securityIssues array is empty based on current _validateCode mapping
		if (securityIssues.length > 0) {
			// Keep this check, though it might be empty
			correctedContent = await this._correctSecurityIssues(
				filePath,
				correctedContent,
				securityIssues, // Will be empty unless `_validateCode` explicitly maps to "security"
				context,
				modelName,
				streamId,
				token,
				onCodeChunkCallback
			);
		}

		if (token?.isCancellationRequested) {
			throw new Error("Operation cancelled");
		}

		// Re-validate after primary corrections, if issues persist, then _applyAlternativeCorrections will be called
		// by _generateWithRealTimeFeedback. No need to call it here directly.
		return correctedContent;
	}

	/**
	 * Apply alternative correction strategy when standard corrections fail
	 */
	private async _applyAlternativeCorrections(
		filePath: string,
		content: string,
		issues: CodeIssue[],
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<string> {
		const languageId = this._getLanguageId(path.extname(filePath));
		// MODIFIED: Replace issue formatting
		const groupedAndPrioritizedIssues = this._groupAndPrioritizeIssues(issues);
		const formattedIssues = this._formatGroupedIssuesForPrompt(
			groupedAndPrioritizedIssues,
			languageId,
			content
		);

		const alternativePrompt = `The code has the following **VS Code-reported compilation/linting issues** that need to be fixed using a different approach:

**Issues to Address:**
${formattedIssues}

**Current Content:**
\`\`\`${languageId}
${content}
\`\`\`

**Alternative Correction Strategy:**
- **PRIORITY: ZERO ERRORS/WARNINGS**: Your primary objective is to resolve ALL reported issues in this single refinement attempt. The resulting code MUST compile and run without any errors or warnings.
-   **Surgical Precision**: Apply *only* the most targeted and minimal changes necessary to resolve the *exact* reported issues. Do not introduce any unrelated refactoring, reformatting, or cosmetic alterations.
-   **Preserve Surrounding Code**: Leave all code lines and blocks untouched if they are not directly involved in resolving an identified diagnostic.
-   **Maintain Indentation/Formatting**: Strictly adhere to the existing indentation, spacing, and formatting conventions of the original code.
- Implement a genuinely different problem-solving approach to fix these issues, strictly avoiding re-attempting similar fixes that have failed or were unproductive.
- Consider architectural changes if needed
- Focus on the root cause rather than symptoms
- Ensure the solution is more robust and maintainable
- **Proactive Error Mitigation**: Anticipate and guard against common pitfalls, such as null/undefined checks, input validations, edge cases, and off-by-one errors.
- **Production Readiness**: Ensure the solution is robust, maintainable, secure, clean, and efficient, adhering to industry best practices for production-ready code.

**Context:**
${context.projectContext}

**Snippets:**
${context.relevantSnippets}

${
	context.activeSymbolInfo
		? `**Active Symbol Info:**
- **Contextual Accuracy**: Use this info for correct integration, signatures, types, and naming for code interacting with these symbols.
${JSON.stringify(context.activeSymbolInfo, null, 2)}`
		: ""
}

${
	context.fileStructureAnalysis
		? this._formatFileStructureAnalysis(context.fileStructureAnalysis) + "\n"
		: ""
}

${
	context.successfulChangeHistory
		? `
**Change History:**
Analyze past successful patterns and apply effective solution strategies.
${context.successfulChangeHistory}
`
		: ""
}
${
	context.isOscillating
		? `--- DETECTED CORRECTION OSCILLATION ---
**WARNING**: It appears the AI is stuck in a repetitive correction cycle, unable to resolve or continually re-introducing the same set of issues across recent attempts. This often happens when the AI tries similar fixes repeatedly without understanding the underlying cause or when changes conflict with other parts of the code.
**CRITICAL DIRECTIVE**: You MUST adopt a completely different, fundamentally new approach to break this cycle. Do NOT repeat similar failed attempts or minor adjustments. Analyze the historical outcomes from 'Recent Correction Attempt Outcomes' for patterns and propose a genuinely new correction strategy that tackles the problem from a different angle. This might involve:
-   Re-evaluating fundamental assumptions about the code or problem.
-   Considering alternative architectural patterns.
-   Breaking down the problem into smaller, more manageable sub-problems.
-   Searching for external documentation or examples if a common pattern is being misapplied.
-   Introducing new helper functions or refactoring a larger section if the existing structure is hostile to the fix.
--- END DETECTED CORRECTION OSCILLATION ---
`
		: ""
}
${
	context.lastCorrectionAttemptOutcome?.aiFailureAnalysis
		? `--- AI Self-Correction Analysis (from previous failed attempt) ---
**CRITICAL**: Read and internalize this analysis. It details *why* your previous attempt failed. You MUST adjust your strategy based on these insights to avoid repeating past mistakes.
**Previous Failure Analysis**:
${context.lastCorrectionAttemptOutcome.aiFailureAnalysis}
--- End AI Self-Correction Analysis ---
`
		: ""
}

**CRITICAL NEGATIVE CONSTRAINT**: Your response MUST ONLY contain the code for the SINGLE target file. DO NOT include any file headers, separators, or meta-information (e.g., \`--- File: ... ---\`, \`--- Relevant File: ... ---\`, \`--- Path: ... ---\`, \`--- End File ---\`, or any form of file delimiters) in your output. Your response must **start directly with the pure code content** on the first line and **end directly with the pure code content** on the last line, with no conversational text, explanations, or extraneous elements whatsoever.

Your response MUST contain **ONLY** the modified file content. **ONLY ADD PURE CODE, NOTHING ELSE, ONLY CODE.** **ABSOLUTELY NO MARKDOWN CODE BLOCK FENCES (\`\`\`typescript), NO CONVERSATIONAL TEXT, NO EXPLANATIONS, NO APOLOGIES, NO COMMENTS, NO EXTRA ELEMENTS WHATSOEVER.**`;

		const rawContent = await this.aiRequestService.generateWithRetry(
			[{ text: alternativePrompt }], // Modified: Wrap prompt string in HistoryEntryPart array
			modelName,
			undefined,
			"alternative code correction",
			undefined,
			{
				onChunk: async (chunk: string) => {
					this.postMessageToWebview({
						type: "codeFileStreamChunk",
						value: { streamId: streamId, filePath: filePath, chunk: chunk },
					});
					if (onCodeChunkCallback) {
						await onCodeChunkCallback(chunk);
					}
				},
			},
			token
		);
		return cleanCodeOutput(rawContent);
	}

	/**
	 * Correct syntax issues
	 */
	private async _correctSyntaxIssues(
		filePath: string,
		content: string,
		issues: CodeIssue[],
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<string> {
		const languageId = this._getLanguageId(path.extname(filePath));
		// MODIFIED: Replace issue formatting
		const groupedAndPrioritizedIssues = this._groupAndPrioritizeIssues(issues);
		const formattedIssues = this._formatGroupedIssuesForPrompt(
			groupedAndPrioritizedIssues,
			languageId,
			content
		);

		const syntaxPrompt = `Fix the following **VS Code-reported compilation/linting issues** (syntax errors) in the code:

**Syntax Issues:**
${formattedIssues}

**Current Content:**
\`\`\`${languageId}
${content}
\`\`\`

**Correction Instructions:**
- **PRIORITY: ZERO ERRORS/WARNINGS**: Your primary objective is to resolve ALL reported issues in this single refinement attempt. The resulting code MUST compile and run without any errors or warnings.
- **Learn from History**: Analyze and learn from the provided Successful Change History to replicate effective solutions, and from the Failed Correction Diff to understand past failures and avoid repeating unproductive strategies.
-   **Surgical Precision**: Apply *only* the most targeted and minimal changes necessary to resolve the *exact* reported issues. Do not introduce any unrelated refactoring, reformatting, or cosmetic alterations.
-   **Preserve Surrounding Code**: Leave all code lines and blocks untouched if they are not directly involved in resolving an identified diagnostic.
-   **Maintain Indentation/Formatting**: Strictly adhere to the existing indentation, spacing, and formatting conventions of the original code.
- **Proactive Error Mitigation**: Beyond fixing the immediate issues, proactively prevent future occurrences where applicable, such as robust type usage, proper import organization, secure data handling, and comprehensive null/undefined checks.
- Fix all syntax errors
- Ensure proper language syntax
- Maintain the original functionality
- Keep the code structure intact

**Context:**
${context.projectContext}

**Snippets:**
${context.relevantSnippets}

${
	context.activeSymbolInfo
		? `**Active Symbol Info:**
- **Contextual Accuracy**: Use this info for correct integration, signatures, types, and naming for code interacting with these symbols.
${JSON.stringify(context.activeSymbolInfo, null, 2)}`
		: ""
}

${
	context.fileStructureAnalysis
		? this._formatFileStructureAnalysis(context.fileStructureAnalysis) + "\n"
		: ""
}

${
	context.successfulChangeHistory
		? `
**Change History:**
Analyze past successful patterns and apply effective solution strategies.
${context.successfulChangeHistory}
`
		: ""
}
${
	context.isOscillating
		? `--- DETECTED CORRECTION OSCILLATION ---
**WARNING**: It appears the AI is stuck in a repetitive correction cycle, unable to resolve or continually re-introducing the same set of issues across recent attempts. This often happens when the AI tries similar fixes repeatedly without understanding the underlying cause or when changes conflict with other parts of the code.
**CRITICAL DIRECTIVE**: You MUST adopt a completely different, fundamentally new approach to break this cycle. Do NOT repeat similar failed attempts or minor adjustments. Analyze the historical outcomes from 'Recent Correction Attempt Outcomes' for patterns and propose a genuinely new correction strategy that tackles the problem from a different angle. This might involve:
-   Re-evaluating fundamental assumptions about the code or problem.
-   Considering alternative architectural patterns.
-   Breaking down the problem into smaller, more manageable sub-problems.
-   Searching for external documentation or examples if a common pattern is being misapplied.
-   Introducing new helper functions or refactoring a larger section if the existing structure is hostile to the fix.
--- END DETECTED CORRECTION OSCILLATION ---
`
		: ""
}
${
	context.lastCorrectionAttemptOutcome?.aiFailureAnalysis
		? `--- AI Self-Correction Analysis (from previous failed attempt) ---
**CRITICAL**: Read and internalize this analysis. It details *why* your previous attempt failed. You MUST adjust your strategy based on these insights to avoid repeating past mistakes.
**Previous Failure Analysis**:
${context.lastCorrectionAttemptOutcome.aiFailureAnalysis}
--- End AI Self-Correction Analysis ---
`
		: ""
}

**CRITICAL NEGATIVE CONSTRAINT**: Your response MUST ONLY contain the code for the SINGLE target file. DO NOT include any file headers, separators, or meta-information (e.g., \`--- File: ... ---\`, \`--- Relevant File: ... ---\`, \`--- Path: ... ---\`, \`--- End File ---\`, or any form of file delimiters) in your output. Your response must **start directly with the pure code content** on the first line and **end directly with the pure code content** on the last line, with no conversational text, explanations, or extraneous elements whatsoever.

Your response MUST contain **ONLY** the modified file content. **ONLY ADD PURE CODE, NOTHING ELSE, ONLY CODE.** **ABSOLUTELY NO MARKDOWN CODE BLOCK FENCES (\`\`\`typescript), NO CONVERSATIONAL TEXT, NO EXPLANATIONS, NO APOLOGIES, NO COMMENTS, NO EXTRA ELEMENTS WHATSOEVER.**`;

		const rawContent = await this.aiRequestService.generateWithRetry(
			[{ text: syntaxPrompt }], // Modified: Wrap prompt string in HistoryEntryPart array
			modelName,
			undefined,
			"syntax correction",
			undefined,
			{
				onChunk: async (chunk: string) => {
					this.postMessageToWebview({
						type: "codeFileStreamChunk",
						value: { streamId: streamId, filePath: filePath, chunk: chunk },
					});
					if (onCodeChunkCallback) {
						await onCodeChunkCallback(chunk);
					}
				},
			},
			token
		);
		return cleanCodeOutput(rawContent);
	}

	/**
	 * Correct import issues
	 */
	private async _correctImportIssues(
		filePath: string,
		content: string,
		issues: CodeIssue[],
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<string> {
		const languageId = this._getLanguageId(path.extname(filePath));
		// MODIFIED: Replace issue formatting
		const groupedAndPrioritizedIssues = this._groupAndPrioritizeIssues(issues);
		const formattedIssues = this._formatGroupedIssuesForPrompt(
			groupedAndPrioritizedIssues,
			languageId,
			content
		);

		const importPrompt = `Fix the following **VS Code-reported compilation/linting issues** (import errors/warnings) in the code:

**Import Issues:**
${formattedIssues}

**Current Content:**
\`\`\`${languageId}
${content}
\`\`\`

**Correction Instructions:**
- **PRIORITY: ZERO ERRORS/WARNINGS**: Your primary objective is to resolve ALL reported issues in this single refinement attempt. The resulting code MUST compile and run without any errors or warnings.
- **Learn from History**: Analyze and learn from the provided Successful Change History to replicate effective solutions, and from the Failed Correction Diff to understand past failures and avoid repeating unproductive strategies.
-   **Surgical Precision**: Apply *only* the most targeted and minimal changes necessary to resolve the *exact* reported issues. Do not introduce any unrelated refactoring, reformatting, or cosmetic alterations.
-   **Preserve Surrounding Code**: Leave all code lines and blocks untouched if they are not directly involved in resolving an identified diagnostic.
-   **Maintain Indentation/Formatting**: Strictly adhere to the existing indentation, spacing, and formatting conventions of the original code.
- **Proactive Error Mitigation**: Beyond fixing the immediate issues, proactively prevent future occurrences where applicable, such as robust type usage, proper import organization, secure data handling, and comprehensive null/undefined checks.
- Remove unused imports
- Add missing imports
- Fix import paths
- Ensure all imports are necessary and correct

**Context:**
${context.projectContext}

**Snippets:**
${context.relevantSnippets}

${
	context.activeSymbolInfo
		? `**Active Symbol Info:**
- **Contextual Accuracy**: Use this info for correct integration, signatures, types, and naming for code interacting with these symbols.
${JSON.stringify(context.activeSymbolInfo, null, 2)}`
		: ""
}

${
	context.fileStructureAnalysis
		? this._formatFileStructureAnalysis(context.fileStructureAnalysis) + "\n"
		: ""
}

${
	context.successfulChangeHistory
		? `
**Change History:**
Analyze past successful patterns and apply effective solution strategies.
${context.successfulChangeHistory}
`
		: ""
}
${
	context.isOscillating
		? `--- DETECTED CORRECTION OSCILLATION ---
**WARNING**: It appears the AI is stuck in a repetitive correction cycle, unable to resolve or continually re-introducing the same set of issues across recent attempts. This often happens when the AI tries similar fixes repeatedly without understanding the underlying cause or when changes conflict with other parts of the code.
**CRITICAL DIRECTIVE**: You MUST adopt a completely different, fundamentally new approach to break this cycle. Do NOT repeat similar failed attempts or minor adjustments. Analyze the historical outcomes from 'Recent Correction Attempt Outcomes' for patterns and propose a genuinely new correction strategy that tackles the problem from a different angle. This might involve:
-   Re-evaluating fundamental assumptions about the code or problem.
-   Considering alternative architectural patterns.
-   Breaking down the problem into smaller, more manageable sub-problems.
-   Searching for external documentation or examples if a common pattern is being misapplied.
-   Introducing new helper functions or refactoring a larger section if the existing structure is hostile to the fix.
--- END DETECTED CORRECTION OSCILLATION ---
`
		: ""
}
${
	context.lastCorrectionAttemptOutcome?.aiFailureAnalysis
		? `--- AI Self-Correction Analysis (from previous failed attempt) ---
**CRITICAL**: Read and internalize this analysis. It details *why* your previous attempt failed. You MUST adjust your strategy based on these insights to avoid repeating past mistakes.
**Previous Failure Analysis**:
${context.lastCorrectionAttemptOutcome.aiFailureAnalysis}
--- End AI Self-Correction Analysis ---
`
		: ""
}

**CRITICAL NEGATIVE CONSTRAINT**: Your response MUST ONLY contain the code for the SINGLE target file. DO NOT include any file headers, separators, or meta-information (e.g., \`--- File: ... ---\`, \`--- Relevant File: ... ---\`, \`--- Path: ... ---\`, \`--- End File ---\`, or any form of file delimiters) in your output. Your response must **start directly with the pure code content** on the first line and **end directly with the pure code content** on the last line, with no conversational text, explanations, or extraneous elements whatsoever.

Your response MUST contain **ONLY** the modified file content. **ONLY ADD PURE CODE, NOTHING ELSE, ONLY CODE.** **ABSOLUTELY NO MARKDOWN CODE BLOCK FENCES (\`\`\`typescript), NO CONVERSATIONAL TEXT, NO EXPLANATIONS, NO APOLOGIES, NO COMMENTS, NO EXTRA ELEMENTS WHATSOEVER.**`;

		const rawContent = await this.aiRequestService.generateWithRetry(
			[{ text: importPrompt }], // Modified: Wrap prompt string in HistoryEntryPart array
			modelName,
			undefined,
			"import correction",
			undefined,
			{
				onChunk: async (chunk: string) => {
					this.postMessageToWebview({
						type: "codeFileStreamChunk",
						value: { streamId: streamId, filePath: filePath, chunk: chunk },
					});
					if (onCodeChunkCallback) {
						await onCodeChunkCallback(chunk);
					}
				},
			},
			token
		);
		return cleanCodeOutput(rawContent);
	}

	/**
	 * Correct best practice issues
	 */ private async _correctPracticeIssues(
		filePath: string,
		content: string,
		issues: CodeIssue[],
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<string> {
		const languageId = this._getLanguageId(path.extname(filePath));
		// MODIFIED: Replace issue formatting
		const groupedAndPrioritizedIssues = this._groupAndPrioritizeIssues(issues);
		const formattedIssues = this._formatGroupedIssuesForPrompt(
			groupedAndPrioritizedIssues,
			languageId,
			content
		);

		const practicePrompt = `Fix the following **VS Code-reported compilation/linting issues** (best practice or other general issues) in the code:

**Issues to Address:**
${formattedIssues}

**Current Content:**
\`\`\`${languageId}
${content}
\`\`\`

**Correction Instructions:**
- **PRIORITY: ZERO ERRORS/WARNINGS**: Your primary objective is to resolve ALL reported issues in this single refinement attempt. The resulting code MUST compile and run without any errors or warnings.
- **Learn from History**: Analyze and learn from the provided Successful Change History to replicate effective solutions, and from the Failed Correction Diff to understand past failures and avoid repeating unproductive strategies.
-   **Surgical Precision**: Apply *only* the most targeted and minimal changes necessary to resolve the *exact* reported issues. Do not introduce any unrelated refactoring, reformatting, or cosmetic alterations.
-   **Preserve Surrounding Code**: Leave all code lines and blocks untouched if they are not directly involved in resolving an identified diagnostic.
-   **Maintain Indentation/Formatting**: Strictly adhere to the existing indentation, spacing, and formatting conventions of the original code.
- **Proactive Error Mitigation**: Beyond fixing the immediate issues, proactively prevent future occurrences where applicable, such as robust type usage, proper import organization, secure data handling, and comprehensive null/undefined checks.
- Follow coding best practices
- Improve code readability
- Use proper naming conventions
- Apply design patterns where appropriate
- Ensure code is maintainable
- Address any other identified issues that are not syntax or import related.

**Context:**
${context.projectContext}

**Snippets:**
${context.relevantSnippets}

${
	context.activeSymbolInfo
		? `**Active Symbol Info:**
- **Contextual Accuracy**: Use this info for correct integration, signatures, types, and naming for code interacting with these symbols.
${JSON.stringify(context.activeSymbolInfo, null, 2)}`
		: ""
}

${
	context.fileStructureAnalysis
		? this._formatFileStructureAnalysis(context.fileStructureAnalysis) + "\n"
		: ""
}

${
	context.successfulChangeHistory
		? `
**Change History:**
Analyze past successful patterns and apply effective solution strategies.
${context.successfulChangeHistory}
`
		: ""
}
${
	context.isOscillating
		? `--- DETECTED CORRECTION OSCILLATION ---
**WARNING**: It appears the AI is stuck in a repetitive correction cycle, unable to resolve or continually re-introducing the same set of issues across recent attempts. This often happens when the AI tries similar fixes repeatedly without understanding the underlying cause or when changes conflict with other parts of the code.
**CRITICAL DIRECTIVE**: You MUST adopt a completely different, fundamentally new approach to break this cycle. Do NOT repeat similar failed attempts or minor adjustments. Analyze the historical outcomes from 'Recent Correction Attempt Outcomes' for patterns and propose a genuinely new correction strategy that tackles the problem from a different angle. This might involve:
-   Re-evaluating fundamental assumptions about the code or problem.
-   Considering alternative architectural patterns.
-   Breaking down the problem into smaller, more manageable sub-problems.
-   Searching for external documentation or examples if a common pattern is being misapplied.
-   Introducing new helper functions or refactoring a larger section if the existing structure is hostile to the fix.
--- END DETECTED CORRECTION OSCILLATION ---
`
		: ""
}
${
	context.lastCorrectionAttemptOutcome?.aiFailureAnalysis
		? `--- AI Self-Correction Analysis (from previous failed attempt) ---
**CRITICAL**: Read and internalize this analysis. It details *why* your previous attempt failed. You MUST adjust your strategy based on these insights to avoid repeating past mistakes.
**Previous Failure Analysis**:
${context.lastCorrectionAttemptOutcome.aiFailureAnalysis}
--- End AI Self-Correction Analysis ---
`
		: ""
}

**CRITICAL NEGATIVE CONSTRAINT**: Your response MUST ONLY contain the code for the SINGLE target file. DO NOT include any file headers, separators, or meta-information (e.g., \`--- File: ... ---\`, \`--- Relevant File: ... ---\`, \`--- Path: ... ---\`, \`--- End File ---\`, or any form of file delimiters) in your output. Your response must **start directly with the pure code content** on the first line and **end directly with the pure code content** on the last line, with no conversational text, explanations, or extraneous elements whatsoever.

Your response MUST contain **ONLY** the modified file content. **ONLY ADD PURE CODE, NOTHING ELSE, ONLY CODE.** **ABSOLUTELY NO MARKDOWN CODE BLOCK FENCES (\`\`\`typescript), NO CONVERSATIONAL TEXT, NO EXPLANATIONS, NO APOLOGIES, NO COMMENTS, NO EXTRA ELEMENTS WHATSOEVER.**`;

		const rawContent = await this.aiRequestService.generateWithRetry(
			[{ text: practicePrompt }], // Modified: Wrap prompt string in HistoryEntryPart array
			modelName,
			undefined,
			"best practice correction",
			undefined,
			{
				onChunk: async (chunk: string) => {
					this.postMessageToWebview({
						type: "codeFileStreamChunk",
						value: { filePath: filePath, chunk: chunk, streamId: streamId },
					});
					if (onCodeChunkCallback) {
						await onCodeChunkCallback(chunk);
					}
				},
			},
			token
		);
		return cleanCodeOutput(rawContent);
	}

	/**
	 * Correct security issues
	 */
	private async _correctSecurityIssues(
		filePath: string,
		content: string,
		issues: CodeIssue[],
		context: EnhancedGenerationContext, // MODIFIED: Change context type
		modelName: string,
		streamId: string,
		token?: vscode.CancellationToken,
		onCodeChunkCallback?: (chunk: string) => Promise<void> | void
	): Promise<string> {
		const languageId = this._getLanguageId(path.extname(filePath));
		// MODIFIED: Replace issue formatting
		const groupedAndPrioritizedIssues = this._groupAndPrioritizeIssues(issues);
		const formattedIssues = this._formatGroupedIssuesForPrompt(
			groupedAndPrioritizedIssues,
			languageId,
			content
		);

		const securityPrompt = `Fix the following **VS Code-reported compilation/linting issues** (security vulnerabilities) in the code:

**Security Issues:**
${formattedIssues}

**Current Content:**
\`\`\`${languageId}
${content}
\`\`\`

**Correction Instructions:**
- **PRIORITY: ZERO ERRORS/WARNINGS**: Your primary objective is to resolve ALL reported issues in this single refinement attempt. The resulting code MUST compile and run without any errors or warnings.
- **Learn from History**: Analyze and learn from the provided Successful Change History to replicate effective solutions, and from the Failed Correction Diff to understand past failures and avoid repeating unproductive strategies.
-   **Surgical Precision**: Apply *only* the most targeted and minimal changes necessary to resolve the *exact* reported issues. Do not introduce any unrelated refactoring, reformatting, or cosmetic alterations.
-   **Preserve Surrounding Code**: Leave all code lines and blocks untouched if they are not directly involved in resolving an identified diagnostic.
-   **Maintain Indentation/Formatting**: Strictly adhere to the existing indentation, spacing, and formatting conventions of the original code.
- **Proactive Error Mitigation**: Beyond fixing the immediate issues, proactively prevent future occurrences where applicable, such as robust type usage, proper import organization, secure data handling, and comprehensive null/undefined checks.
- Fix all security vulnerabilities
- Use secure coding practices
- Validate inputs properly
- Handle sensitive data correctly
- Follow security best practices

**Context:**
${context.projectContext}

**Snippets:**
${context.relevantSnippets}

${
	context.activeSymbolInfo
		? `**Active Symbol Info:**
- **Contextual Accuracy**: Use this info for correct integration, signatures, types, and naming for code interacting with these symbols.
${JSON.stringify(context.activeSymbolInfo, null, 2)}`
		: ""
}

${
	context.fileStructureAnalysis
		? this._formatFileStructureAnalysis(context.fileStructureAnalysis) + "\n"
		: ""
}

${
	context.successfulChangeHistory
		? `
**Change History:**
Analyze past successful patterns and apply effective solution strategies.
${context.successfulChangeHistory}
`
		: ""
}
${
	context.isOscillating
		? `--- DETECTED CORRECTION OSCILLATION ---
**WARNING**: It appears the AI is stuck in a repetitive correction cycle, unable to resolve or continually re-introducing the same set of issues across recent attempts. This often happens when the AI tries similar fixes repeatedly without understanding the underlying cause or when changes conflict with other parts of the code.
**CRITICAL DIRECTIVE**: You MUST adopt a completely different, fundamentally new approach to break this cycle. Do NOT repeat similar failed attempts or minor adjustments. Analyze the historical outcomes from 'Recent Correction Attempt Outcomes' for patterns and propose a genuinely new correction strategy that tackles the problem from a different angle. This might involve:
-   Re-evaluating fundamental assumptions about the code or problem.
-   Considering alternative architectural patterns.
-   Breaking down the problem into smaller, more manageable sub-problems.
-   Searching for external documentation or examples if a common pattern is being misapplied.
-   Introducing new helper functions or refactoring a larger section if the existing structure is hostile to the fix.
--- END DETECTED CORRECTION OSCILLATION ---
`
		: ""
}
${
	context.lastCorrectionAttemptOutcome?.aiFailureAnalysis
		? `--- AI Self-Correction Analysis (from previous failed attempt) ---
**CRITICAL**: Read and internalize this analysis. It details *why* your previous attempt failed. You MUST adjust your strategy based on these insights to avoid repeating past mistakes.
**Previous Failure Analysis**:
${context.lastCorrectionAttemptOutcome.aiFailureAnalysis}
--- End AI Self-Correction Analysis ---
`
		: ""
}

**CRITICAL NEGATIVE CONSTRAINT**: Your response MUST ONLY contain the code for the SINGLE target file. DO NOT include any file headers, separators, or meta-information (e.g., \`--- File: ... ---\`, \`--- Relevant File: ... ---\`, \`--- Path: ... ---\`, \`--- End File ---\`, or any form of file delimiters) in your output. Your response must **start directly with the pure code content** on the first line and **end directly with the pure code content** on the last line, with no conversational text, explanations, or extraneous elements whatsoever.

Your response MUST contain **ONLY** the modified file content. **ONLY ADD PURE CODE, NOTHING ELSE, ONLY CODE.** **ABSOLUTELY NO MARKDOWN CODE BLOCK FENCES (\`\`\`typescript), NO CONVERSATIONAL TEXT, NO EXPLANATIONS, NO APOLOGIES, NO COMMENTS, NO EXTRA ELEMENTS WHATSOEVER.**`;

		const rawContent = await this.aiRequestService.generateWithRetry(
			[{ text: securityPrompt }], // Modified: Wrap prompt string in HistoryEntryPart array
			modelName,
			undefined,
			"security correction",
			undefined,
			{
				onChunk: async (chunk: string) => {
					this.postMessageToWebview({
						type: "codeFileStreamChunk",
						value: { streamId: streamId, filePath: filePath, chunk: chunk },
					});
					if (onCodeChunkCallback) {
						await onCodeChunkCallback(chunk);
					}
				},
			},
			token
		);
		return cleanCodeOutput(rawContent);
	}

	/**
	 * Send feedback to callback if provided
	 */
	private _sendFeedback(
		callback?: (feedback: RealTimeFeedback) => void,
		feedback?: RealTimeFeedback
	): void {
		if (callback && feedback) {
			try {
				callback(feedback);
			} catch (error) {
				console.warn("Error in feedback callback:", error);
			}
		}
	}
}
